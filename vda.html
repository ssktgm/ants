<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配車調整アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ドラッグ中の要素のスタイル */
        .dragging { opacity: 0.5; } /* opacity-50 */
        
        /* ドラッグ可能なアイテム */
        .draggable-item {
            cursor: move;
            /* ★タッチ操作時にテキスト選択が起こらないようにする */
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
        }

        /* ★ドロップ先(移動)のハイライト */
        .members-dropzone.drop-target-move { 
            background-color: #EFF6FF; /* blue-50 */
        }
        
        /* ★ドロップ先(入れ替え)のハイライト */
        .driver-dropzone.drop-target-swap, .draggable-item.drop-target-swap {
            outline: 2px dashed #3B82F6; /* blue-500 */
            outline-offset: -2px;
        }
        
        /* ★ドロップ先(挿入)のハイライト */
        .draggable-item.drop-target-insert-before::before {
            content: '';
            display: block;
            height: 3px;
            background-color: #3B82F6; /* blue-500 */
            margin-bottom: -1px; /* Adjust spacing */
        }
        .draggable-item.drop-target-insert-after::after {
             content: '';
            display: block;
            height: 3px;
            background-color: #3B82F6; /* blue-500 */
             margin-top: -1px; /* Adjust spacing */
        }

        /* ★ドロップ先(定員オーバー) */
        .members-dropzone.drop-target-full, .driver-dropzone.drop-target-full, .draggable-item.drop-target-full { 
            background-color: #FEF2F2 !important; /* red-50, importantで上書き */
             outline: 2px dashed #F87171 !important; /* red-400 */
             outline-offset: -2px;
        }
        
        /* details[open] summary のスタイル */
        details[open] > summary {
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
        }
        /* ファイル入力ボタンを隠す */
        #import-state-input, #import-master-input {
            display: none;
        }

        /* 可変グリッドレイアウトのためのCSS */
        .main-grid-layout {
            display: grid;
            grid-template-columns: repeat(1, minmax(0, 1fr)); /* default: 1 col */
            gap: 1.5rem; /* gap-6 */
        }
        
        /* 結果表示用のグリッドレイアウト */
        .results-grid-layout {
            display: grid;
            grid-template-columns: repeat(1, minmax(0, 1fr)); /* default: 1 col */
            gap: 1rem; /* gap-4 */
        }

        @media (min-width: 768px) { /* md: breakpoint */
            .main-grid-layout {
                grid-template-columns: repeat(var(--layout-columns, 3), minmax(0, 1fr));
            }
            .results-grid-layout {
                grid-template-columns: repeat(var(--layout-columns, 3), minmax(0, 1fr));
            }
        }
        /* ゴースト要素のスタイル */
        #ghost-element {
            position: absolute;
            z-index: 1000;
            opacity: 0.8;
            pointer-events: none;
            background-color: white; /* 背景色を追加して見やすく */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 影を追加 */
            padding: 0.5rem; /* li要素のpaddingに合わせる */
            border-radius: 0.375rem; /* li要素のroundedに合わせる */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">配車調整アプリ</h1>

        <!-- ファイル入出力ボタン -->
        <section class="mb-6 grid grid-cols-2 gap-2 max-w-md">
            <!-- 状態 -->
            <button id="export-state-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-200">
                状態を保存 (JSON)
            </button>
            <label for="import-state-input" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-200 cursor-pointer text-center">
                状態を読み込む (JSON)
            </label>
            <input type="file" id="import-state-input" accept=".json">

            <!-- マスターデータ -->
            <button id="export-master-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-200">
                マスターを保存 (JSON)
            </button>
            <label for="import-master-input" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-200 cursor-pointer text-center">
                マスターを読み込む (JSON)
            </label>
            <input type="file" id="import-master-input" accept=".json">
        </section>


        <!-- メッセージエリア -->
        <div id="message" class="hidden p-4 mb-4 border rounded-lg" role="alert">
            <span id="message-text"></span>
            <button id="message-close" type="button" class="float-right font-bold text-lg leading-none">&times;</button>
        </div>

        <!-- メインコンテンツグリッド -->
        <div id="main-content" class="main-grid-layout">

            <!-- ステップ 1: 参加者選択 -->
            <section>
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-gray-700">1. 参加者を選択</h2>
                    <button id="toggle-details-button" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-1 px-3 rounded-lg text-sm transition duration-200">
                        すべて閉じる
                    </button>
                </div>
                <div id="participant-list" class="space-y-2 h-[600px] overflow-y-auto bg-white p-4 rounded-lg shadow">
                    <!-- JSで描画 -->
                </div>
            </section>

            <!-- ステップ 2: 車選択 -->
            <section>
                <h2 class="text-xl font-semibold text-gray-700 mb-3">2. 車とドライバーを選択</h2>
                <div id="car-list" class="space-y-3 h-[600px] overflow-y-auto bg-white p-4 rounded-lg shadow">
                    <!-- JSで描画 -->
                </div>
            </section>

            <!-- ステップ 3 & 4: 別便除外 と 実行ボタン -->
            <section>
                <h2 class="text-xl font-semibold text-gray-700 mb-3">3. 別便の人を除外</h2>
                <div id="exclusion-list" class="space-y-2 h-[488px] overflow-y-auto bg-white p-4 rounded-lg shadow min-h-[50px]">
                    <!-- JSで描画 -->
                </div>
                
                <div class="mt-6 text-center">
                    <button id="assign-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-10 rounded-lg shadow-lg transition duration-200 ease-in-out transform hover:scale-105">
                        4. 割り当て実行
                    </button>
                </div>
            </section>

            <!-- ステップ 5: 割り当て結果 -->
            <section id="results-section" class="md:col-span-3"> 
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-gray-700">5. 割り当て結果 (ドラッグ＆ドロップで調整可能)</h2>
                    <button id="show-text-output-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-1 px-3 rounded-lg shadow text-sm transition duration-200">
                        テキスト出力
                    </button>
                </div>

                <!-- テキスト出力エリア -->
                <div id="text-output-container" class="mb-4 hidden">
                    <textarea id="text-output" rows="10" class="w-full p-2 border rounded-lg font-mono text-sm bg-gray-50" readonly></textarea>
                    <button id="copy-text-output-button" class="mt-2 bg-gray-400 hover:bg-gray-500 text-white py-1 px-3 rounded text-sm">
                        コピー
                    </button>
                </div>

                <div id="results" class="results-grid-layout"> 
                    <p id="results-placeholder" class="text-gray-500 text-sm bg-white p-4 rounded-lg shadow min-h-[50px] md:col-span-3">ステップ4の「割り当て実行」を押してください。</p>
                </div>
            </section>

        </div> <!-- main-content 閉じタグ -->

    </div>

    <script type="module">
        // --- レイアウト列数の定義 ---
        const LAYOUT_COLUMNS = 3; 

        // --- 事前定義データ ---
        
        let FAMILIES = [
            { familyName: '小高家', members: [ { id: 'p1', name: '斗愛', type: '選手', isFlagTarget: true, data: { grade: '5年', school: '東小', other: '', memo: '' } }, { id: 'p2', name: '小高監督', type: '保護者', data: { memo: '' } }, { id: 'p3', name: '小高母', type: '保護者', data: { memo: '' } }, { id: 'p22', name: '愛之佑', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '東小', other: '', memo: '' } } ] },
            { familyName: '難波家', members: [ { id: 'p4', name: '諒成', type: '選手', isFlagTarget: true, data: { grade: '5年', school: 'x小', other: '', memo: '' } }, { id: 'p5', name: '難波父', type: '保護者', data: { memo: '' } } ] },
            { familyName: '浪川家', members: [ { id: 'p6', name: '長政', type: '選手', isFlagTarget: true, data: { grade: '5年', school: '小金小', other: '', memo: '' } }, { id: 'p7', name: '浪川父', type: '保護者', data: { memo: '' } }, { id: 'p8', name: '浪川母', type: '保護者', data: { memo: '' } } ] },
            { familyName: '高橋家', members: [ { id: 'p9', name: '湊多', type: '選手', isFlagTarget: true, data: { grade: '5年', school: '東小', other: '', memo: '' } } ] },
            { familyName: '山田家', members: [ { id: 'p10', name: '颯真', type: '選手', isFlagTarget: true, data: { grade: '4年', school: '小金小', other: '', memo: '' } }, { id: 'p11', name: '山田父', type: '保護者', data: { memo: '' } }, { id: 'p12', name: '山田母', type: '保護者', data: { memo: '' } } ] },
            { familyName: '菱沼家', members: [ { id: 'p13', name: '颯介', type: '選手', isFlagTarget: true, data: { grade: '4年', school: '小金小', other: '', memo: '' } }, { id: 'p14', name: '菱沼父', type: '保護者', data: { memo: '' } }, { id: 'p15', name: '菱沼母', type: '保護者', data: { memo: '' } }, { id: 'p16', name: 'つぐみ', type: '兄弟', isFlagTarget: false, data: { grade: '2年', school: '小金小', other: '', memo: '' } } ] },
            { familyName: '小野家', members: [ { id: 'p17', name: '暁人', type: '選手', isFlagTarget: true, data: { grade: '4年', school: '小金小', other: '', memo: '' } }, { id: 'p18', name: '小野母', type: '保護者', data: { memo: '' } }, { id: 'p19', name: 'ななか', type: '兄弟', isFlagTarget: true, data: { grade: '2年', school: '小金小', other: '', memo: '' } } ] },
            { familyName: '津村家', members: [ { id: 'p20', name: '一樹', type: '選手', isFlagTarget: true, data: { grade: '4年', school: '東小', other: '', memo: '' } }, { id: 'p21', name: '津村父', type: '保護者', data: { memo: '' } } ] },
            { familyName: '浅野家', members: [ { id: 'p23', name: '泰地', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '小金小', other: '', memo: '' } }, { id: 'p24', name: '浅野父', type: '保護者', data: { memo: '' } }, { id: 'p25', name: '浅野母', type: '保護者', data: { memo: '' } } ] },
            { familyName: '近藤家', members: [ { id: 'p26', name: '謙成', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '八木南小', other: '', memo: '' } }, { id: 'p44', name: '茉莉', type: '選手', isFlagTarget: true, data: { grade: '1年', school: '八木南小', other: '', memo: '' } } , { id: 'p27', name: '近藤父', type: '保護者', data: { memo: '' } }, { id: 'p28', name: '近藤母', type: '保護者', data: { memo: '' } }, { id: 'p29', name: 'おうすけ', type: '兄弟', isFlagTarget: true, data: { grade: '', school: '', other: '', memo: '' } } ] },
            { familyName: '知野見家', members: [ { id: 'p30', name: '怜央', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '小金小', other: '', memo: '' } }, { id: 'p31', name: '知野見父', type: '保護者', data: { memo: '' } }, { id: 'p32', name: '知野見母', type: '保護者', data: { memo: '' } }, { id: 'p33', name: 'ゆな', type: '兄弟', isFlagTarget: true, data: { grade: '', school: '', other: '', memo: '' } } ] },
            { familyName: '藤山家', members: [ { id: 'p34', name: '琉杜', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '小金小', other: '', memo: '' } }, { id: 'p35', name: '藤山父', type: '保護者', data: { memo: '' } }, { id: 'p36', name: '藤山母', type: '保護者', data: { memo: '' } } ] },
            { familyName: '小河原家', members: [ { id: 'p37', name: '維', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '小金小', other: '', memo: '' } }, { id: 'p38', name: '小河原父', type: '保護者', data: { memo: '' } }, { id: 'p39', name: '小河原母', type: '保護者', data: { memo: '' } } ] },
            { familyName: '古川家', members: [ { id: 'p40', name: '峻丞', type: '選手', isFlagTarget: true, data: { grade: '2年', school: '新松戸南小', other: '', memo: '' } }, { id: 'p41', name: '古川父', type: '保護者', data: { memo: '' } } ] },
            { familyName: '坪井家', members: [ { id: 'p42', name: '雄也', type: '選手', isFlagTarget: true, data: { grade: '1年', school: '東小', other: '', memo: '' } }, { id: 'p43', name: '坪井父', type: '保護者', data: { memo: '' } } ] },
            { familyName: 'スタッフ・個人', members: [ { id: 'p94', name: '渡邉会長', type: 'その他', data: { memo: '' } }, { id: 'p99', name: '木村代表', type: 'その他', data: { memo: '' } }, { id: 'p98', name: '吉田さん', type: 'その他', data: { memo: '' } }, { id: 'p97', name: '前田さん', type: 'その他', data: { memo: '' } }, { id: 'p96', name: '中田さん', type: 'その他', data: { memo: '' } }, { id: 'p95', name: '渡辺さん', type: 'その他', data: { memo: '' } }, ] }
        ];

        let AVAILABLE_CARS_INFO = [
            { id: 'c1', name: '小高カー', familyName: '小高家', baseCapacity: 6 }, { id: 'c2', name: '難波カー', familyName: '難波家', baseCapacity: 7 }, { id: 'c3', name: '浪川カー①', familyName: '浪川家', baseCapacity: 6 }, { id: 'c4', name: '浪川カー②', familyName: '浪川家', baseCapacity: 5 }, { id: 'c5', name: '山田カー①', familyName: '山田家', baseCapacity: 7 }, { id: 'c6', name: '山田カー②', familyName: '山田家', baseCapacity: 5 }, { id: 'c7', name: '菱沼カー', familyName: '菱沼家', baseCapacity: 6 }, { id: 'c8', name: '小野カー', familyName: '小野家', baseCapacity: 8 }, { id: 'c9', name: '浅野カー', familyName: '浅野家', baseCapacity: 8 }, { id: 'c10', name: '近藤カー', familyName: '近藤家', baseCapacity: 6 }, { id: 'c11', name: '知野見カー', familyName: '知野見家', baseCapacity: 7 }, { id: 'c12', name: '藤山カー', familyName: '藤山家', baseCapacity: 4 }, { id: 'c13', name: '小河原カー①', familyName: '小河原家', baseCapacity: 4 }, { id: 'c14', name: '小河原カー②', familyName: '小河原家', baseCapacity: 4 }, { id: 'c15', name: '古川カー', familyName: '古川家', baseCapacity: 8 }, { id: 'c16', name: 'コーチカー', familyName: 'スタッフ・個人', baseCapacity: 5 }
        ];

        let ALL_PARTICIPANTS_FLAT = FAMILIES.flatMap(f => f.members);


        // --- 状態変数 ---
        let selectedParticipantIds = new Set();
        let selectedCarIds = new Set();
        let selectedDrivers = new Map(); // carId -> driverId
        let selectedLuggage = new Set(); // carId
        let excludedParticipantIds = new Set();
        let participantData = new Map(); // participantId -> { grade, school, other, memo }
        let currentAssignments = []; // 割り当て結果: { car..., driver: {p...}, members: [{p...}] }
        
        // ★ ドラッグ操作の状態変数 ★
        let isDragging = false;     // ドラッグ操作中か (マウス/タッチ共通)
        let dragTargetIdInternal = null;  // ★ 内部変数名変更
        let dragSourceCarIdInternal = null; // ★ 内部変数名変更
        let dragIsDriverInternal = false; // ★ 内部変数名変更
        let currentDropModeInternal = null; // ★ 内部変数名変更
        let currentDropTargetIdInternal = null;// ★ 内部変数名変更
        let ghostElement = null; // タッチ操作時のゴースト要素
        let lastTouchMoveClientX = null; // 最後のタッチ座標
        let lastTouchMoveClientY = null;

        // --- DOM参照 ---
        const participantListEl = document.getElementById('participant-list');
        const carListEl = document.getElementById('car-list');
        const exclusionListEl = document.getElementById('exclusion-list');
        const resultsEl = document.getElementById('results');
        const assignButton = document.getElementById('assign-button');
        const messageContainer = document.getElementById('message');
        const messageText = document.getElementById('message-text');
        const messageClose = document.getElementById('message-close');
        const exportButton = document.getElementById('export-state-button');
        const importInput = document.getElementById('import-state-input');
        const showTextOutputButton = document.getElementById('show-text-output-button');
        const textOutputContainer = document.getElementById('text-output-container');
        const textOutputEl = document.getElementById('text-output');
        const copyTextOutputButton = document.getElementById('copy-text-output-button');
        const toggleDetailsButton = document.getElementById('toggle-details-button');
        
        const exportMasterButton = document.getElementById('export-master-button');
        const importMasterInput = document.getElementById('import-master-input');

        // ★★★ 修正: clearDragOverHighlights の定義を先頭に移動 ★★★
        // --- ドラッグ＆ドロップ用 ヘルパー ---
        function clearDragOverHighlights() {
             document.querySelectorAll('.drop-target-swap, .drop-target-insert-before, .drop-target-insert-after, .drop-target-move, .drop-target-full')
                .forEach(el => {
                    el.classList.remove(
                        'drop-target-swap', 
                        'drop-target-insert-before', 
                        'drop-target-insert-after',
                        'drop-target-move',
                        'drop-target-full'
                    );
            });
        }


        // --- 初期化処理 ---
        document.addEventListener('DOMContentLoaded', () => {
            document.documentElement.style.setProperty('--layout-columns', LAYOUT_COLUMNS);
            
            const resultsSection = document.getElementById('results-section');
            function updateLayouts() { 
                const placeholder = document.getElementById('results-placeholder');
                
                if (window.innerWidth >= 768) { // md breakpoint
                    resultsSection.style.gridColumn = `span ${LAYOUT_COLUMNS}`;
                    if (placeholder) {
                        placeholder.style.gridColumn = `span ${LAYOUT_COLUMNS}`;
                    }
                } else {
                    resultsSection.style.gridColumn = 'auto';
                    if (placeholder) {
                        placeholder.style.gridColumn = 'auto';
                    }
                }
            }
            updateLayouts();
            window.addEventListener('resize', updateLayouts); 

            initializeParticipantData(); 
            renderParticipantList();
            renderCarList();
            renderExclusionList();
            
            participantListEl.addEventListener('change', handleParticipantChange);
            participantListEl.addEventListener('input', handleParticipantDataInput); 
            participantListEl.addEventListener('click', handleFamilyCheck); // ★一括チェック
            carListEl.addEventListener('change', handleCarChange);
            exclusionListEl.addEventListener('change', handleExclusionChange);
            assignButton.addEventListener('click', handleAssignment);
            messageClose.addEventListener('click', hideMessage);

            // 標準ドラッグイベント
            resultsEl.addEventListener('dragstart', handleDragStart);
            resultsEl.addEventListener('dragover', handleDragOver);
            resultsEl.addEventListener('drop', handleDrop);
            resultsEl.addEventListener('dragend', handleDragEnd);

            // ★タッチイベントリスナーを追加
            resultsEl.addEventListener('touchstart', handleTouchStart, { passive: false });
            resultsEl.addEventListener('touchmove', handleTouchMove, { passive: false });
            resultsEl.addEventListener('touchend', handleTouchEnd);
            // ★タッチキャンセルも考慮
            resultsEl.addEventListener('touchcancel', _handleDragEnd); // Use _handleDragEnd directly
            
            exportButton.addEventListener('click', handleExportState);
            importInput.addEventListener('change', handleImportState);
            showTextOutputButton.addEventListener('click', handleShowTextOutput);
            copyTextOutputButton.addEventListener('click', handleCopyTextOutput);
            toggleDetailsButton.addEventListener('click', handleToggleDetails);

            exportMasterButton.addEventListener('click', handleExportMasterData);
            importMasterInput.addEventListener('change', handleImportMasterData);
        });

        // 参加者データ（備考含む）を初期化
        function initializeParticipantData() {
            participantData.clear(); 
            FAMILIES.forEach(family => {
                family.members.forEach(member => {
                    const defaultData = { 
                        grade: '', school: '', other: '', memo: '',
                        ...(member.data || {}) // マスターデータにdataがない場合も考慮
                    };
                    
                    if (!member.isFlagTarget) {
                        defaultData.grade = '';
                        defaultData.school = '';
                        defaultData.other = '';
                    }
                    participantData.set(member.id, defaultData);
                });
            });
        }

        // ステップ1: 参加者リストを描画
        function renderParticipantList() {
            participantListEl.innerHTML = '';
            FAMILIES.forEach(family => {
                const details = document.createElement('details');
                details.className = 'bg-gray-50 rounded border';
                details.open = true; // ★デフォルトで開く
                
                const summary = document.createElement('summary');
                summary.className = 'p-3 cursor-pointer select-none flex justify-between items-center';
                
                const summaryTitle = document.createElement('span');
                summaryTitle.className = 'font-semibold';
                summaryTitle.textContent = family.familyName;
                summary.appendChild(summaryTitle);

                // ★一括チェックボタン
                const buttonGroup = document.createElement('div');
                buttonGroup.className = 'space-x-1';
                buttonGroup.innerHTML = `
                    <button data-family-id="${family.familyName}" data-check-action="check" class="text-xs bg-blue-500 hover:bg-blue-600 text-white py-1 px-2 rounded">全員参加</button>
                    <button data-family-id="${family.familyName}" data-check-action="uncheck" class="text-xs bg-gray-400 hover:bg-gray-500 text-white py-1 px-2 rounded">全員不参加</button>
                `;
                summary.appendChild(buttonGroup);

                const memberList = document.createElement('div');
                memberList.className = 'p-3 border-t border-gray-200 space-y-3';

                family.members.forEach(p => {
                    const isChecked = selectedParticipantIds.has(p.id);
                    const wrapper = document.createElement('div');
                    wrapper.className = 'ml-4';

                    // 参加者名とチェックボックス
                    const participantDiv = document.createElement('div');
                    participantDiv.className = 'flex items-center';
                    participantDiv.innerHTML = `
                        <input type="checkbox" id="p-${p.id}" data-id="${p.id}" data-family-id="${family.familyName}" data-action="select-participant" class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${isChecked ? 'checked' : ''}>
                        <label for="p-${p.id}" class="text-gray-700">${p.name} (${p.type})</label>
                    `;
                    wrapper.appendChild(participantDiv);
                    
                    // データ入力欄
                    const data = participantData.get(p.id) || { grade: '', school: '', other: '', memo: '' };
                    const dataDiv = document.createElement('div');
                    dataDiv.id = `data-inputs-${p.id}`; 
                    dataDiv.className = `ml-8 mt-1.5 grid grid-cols-4 gap-2 ${isChecked ? '' : 'opacity-50'}`;
                    
                    if (p.isFlagTarget) {
                        dataDiv.innerHTML = `
                            <input type="text" data-id="${p.id}" data-type="grade" value="${data.grade || ''}" placeholder="学年" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                            <input type="text" data-id="${p.id}" data-type="school" value="${data.school || ''}" placeholder="学校" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                            <input type="text" data-id="${p.id}" data-type="other" value="${data.other || ''}" placeholder="その他" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                            <input type="text" data-id="${p.id}" data-type="memo" value="${data.memo || ''}" placeholder="備考" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                        `;
                    } else {
                        // isFlagTarget: false の場合は備考欄のみ
                        dataDiv.innerHTML = `
                            <div class="col-span-3"></div> <!-- 空白 -->
                            <input type="text" data-id="${p.id}" data-type="memo" value="${data.memo || ''}" placeholder="備考" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                        `;
                    }
                    wrapper.appendChild(dataDiv);
                    memberList.appendChild(wrapper);
                });
                details.appendChild(summary);
                details.appendChild(memberList);
                participantListEl.appendChild(details);
            });
        }
        
        // ★家族一括チェック用
        function handleFamilyCheck(e) {
            const target = e.target.closest('button[data-check-action]');
            if (!target) return;
            
            // summaryの開閉をキャンセル
            e.preventDefault(); 
            
            const familyName = target.dataset.familyId;
            const action = target.dataset.checkAction;
            const shouldCheck = (action === 'check');
            
            const family = FAMILIES.find(f => f.familyName === familyName);
            if (!family) return;
            
            family.members.forEach(member => {
                const checkbox = participantListEl.querySelector(`#p-${member.id}`);
                if (checkbox && checkbox.checked !== shouldCheck) {
                    checkbox.checked = shouldCheck;
                    // changeイベントを強制発火させて状態を更新
                    checkbox.dispatchEvent(new Event('change', { bubbles: true })); 
                }
            });
        }

        // ステップ2: 車リストを描画
        function renderCarList() {
            carListEl.innerHTML = '';
            AVAILABLE_CARS_INFO.forEach(car => {
                const family = FAMILIES.find(f => f.familyName === car.familyName);
                const driverOptions = family ? family.members : ALL_PARTICIPANTS_FLAT; 
                const isChecked = selectedCarIds.has(car.id);
                
                // ★デフォルトドライバーの選定
                let defaultDriverId = '';
                if (family) {
                    // 優先順位：「父」を含む保護者 -> 「母」を含む保護者
                    const father = family.members.find(m => m.type === '保護者' && (m.name.includes('父') || m.name.includes('監督')));
                    const mother = family.members.find(m => m.type === '保護者' && m.name.includes('母'));
                    
                    if (father) {
                        defaultDriverId = father.id;
                    } else if (mother) {
                        defaultDriverId = mother.id;
                    }
                }
                
                // 既に選択済みの値があればそちらを優先
                const driverId = selectedDrivers.get(car.id) || defaultDriverId;
                if(defaultDriverId && !selectedDrivers.has(car.id)) {
                     selectedDrivers.set(car.id, defaultDriverId); // 状態にもセット
                }
                
                const hasLuggage = selectedLuggage.has(car.id);
                const div = document.createElement('div');
                div.className = 'bg-gray-50 rounded border p-3';
                div.dataset.carId = car.id;
                div.innerHTML = `
                    <div class="flex items-center">
                        <input type="checkbox" id="c-${car.id}" data-id="${car.id}" data-action="select-car" class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${isChecked ? 'checked' : ''}>
                        <label for="c-${car.id}" class="font-semibold">${car.name} (定員${car.baseCapacity}名)</label>
                    </div>
                    <div id="car-options-${car.id}" class="ml-8 mt-3 space-y-3 ${isChecked ? '' : 'hidden'}">
                        <div>
                            <label for="driver-${car.id}" class="block text-sm font-medium text-gray-700">ドライバー:</label>
                            <select id="driver-${car.id}" data-action="select-driver" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                                <option value="">選択してください</option>
                                ${driverOptions.map(p => `<option value="${p.id}" ${driverId === p.id ? 'selected' : ''}>${p.name} (${p.type})</option>`).join('')}
                            </select>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="luggage-${car.id}" data-action="select-luggage" class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${hasLuggage ? 'checked' : ''}>
                            <label for="luggage-${car.id}" class="text-sm text-gray-700">荷物あり (乗客定員1名)</label>
                        </div>
                    </div>
                `;
                carListEl.appendChild(div);
            });
        }

        // ステップ3: 除外リストを描画
        function renderExclusionList() {
            exclusionListEl.innerHTML = '';
            const participants = ALL_PARTICIPANTS_FLAT.filter(p => selectedParticipantIds.has(p.id));
            if (participants.length === 0) {
                exclusionListEl.innerHTML = '<p class="text-gray-500 text-sm">ステップ1で参加者を選択してください。</p>';
                return;
            }
            participants.forEach(p => {
                const div = document.createElement('div');
                div.className = 'flex items-center';
                div.innerHTML = `
                    <input type="checkbox" id="ex-${p.id}" data-id="${p.id}" data-action="exclude-participant" class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${excludedParticipantIds.has(p.id) ? 'checked' : ''}>
                    <label for="ex-${p.id}" class="text-gray-700">${p.name} (${p.type})</label>
                `;
                exclusionListEl.appendChild(div);
            });
        }

        // ステップ5: 割り当て結果を描画
        function renderResults(assignments) {
            resultsEl.innerHTML = '';
            
            if (assignments.length === 0) {
                resultsEl.innerHTML = `<p id="results-placeholder" class="text-gray-500 text-sm bg-white p-4 rounded-lg shadow min-h-[50px] md:col-span-3">ステップ4の「割り当て実行」を押してください。</p>`;
                const placeholder = document.getElementById('results-placeholder');
                if (placeholder) {
                     if (window.innerWidth >= 768) { 
                        placeholder.style.gridColumn = `span ${LAYOUT_COLUMNS}`;
                    } else {
                        placeholder.style.gridColumn = 'auto';
                    }
                }
                return;
            }

            assignments.forEach(car => {
                const card = document.createElement('div');
                card.id = `car-result-${car.id}`;
                card.dataset.carId = car.id; 
                card.className = 'bg-white border rounded-lg shadow-md car-dropzone flex flex-col'; // flex-colを追加
                
                let headerHtml = '';
                let driverHtml = '';
                
                if (car.id === 'excluded-car') {
                    headerHtml = `
                        <div class="p-4 border-b bg-gray-100 flex-shrink-0">
                            <h4 class="font-bold text-lg text-gray-700">${car.name}</h4>
                            <p class="text-sm text-gray-600">合計: ${car.members.length}名</p>
                        </div>`;
                    driverHtml = `<div id="driver-dropzone-${car.id}" class="driver-dropzone flex-shrink-0"></div>`; // 空だが必須
                } else {
                    const vacancy = car.capacity - car.members.length;
                    const luggageInfo = car.hasLuggage ? ' (荷物あり)' : '';
                    headerHtml = `
                        <div class="p-4 border-b flex-shrink-0">
                            <h4 class="font-bold text-lg">${car.name} ${luggageInfo}</h4>
                            <p class="text-sm font-medium ${vacancy < 0 ? 'text-red-600' : 'text-blue-600'}">
                                定員 ${car.capacity}名 (空き ${vacancy}名)
                            </p>
                        </div>`;
                    
                    const d = car.driver;
                    if (d) {
                        const memo = (participantData.get(d.id)?.memo || '').trim();
                        // ドライバー要素に data-drag-handle を追加
                        driverHtml = `
                        <div id="driver-dropzone-${car.id}" class="p-4 border-b driver-dropzone flex-shrink-0" data-drop-type="driver">
                            <li id="p-result-${d.id}" data-participant-id="${d.id}" data-is-driver="true" draggable="true" 
                                class="p-2 bg-blue-100 rounded shadow-sm flex justify-between items-center draggable-item">
                                <div data-drag-handle="true" class="min-w-0">
                                    <span class="font-semibold text-blue-800 break-words" data-drag-handle="true">[D] ${d.name} (${d.type})</span>
                                    ${memo ? `<span class="text-xs text-blue-600 ml-2 break-words" data-drag-handle="true">[${memo}]</span>` : ''}
                                </div>
                            </li>
                        </div>`;
                    } else {
                         driverHtml = `
                         <div id="driver-dropzone-${car.id}" class="p-4 border-b driver-dropzone min-h-[50px] bg-red-50 flex-shrink-0" data-drop-type="driver">
                             <p class="text-red-700 text-sm">ドライバーがいません</p>
                         </div>`;
                    }
                }
                
                const membersHtml = car.members.map(p => {
                    const memo = (participantData.get(p.id)?.memo || '').trim();
                    const flags = (p.isFlagTarget && (p.grade || p.school || p.other)) 
                        ? [p.grade, p.school, p.other].filter(Boolean).join(' ') 
                        : '';
                    // 乗客要素に data-drag-handle を追加
                    return `
                    <li id="p-result-${p.id}" data-participant-id="${p.id}" data-is-driver="false" draggable="true" 
                        class="p-2 bg-gray-100 rounded shadow-sm flex justify-between items-center draggable-item">
                        <div data-drag-handle="true" class="min-w-0">
                            <span data-drag-handle="true" class="break-words">${p.name} (${p.type})</span>
                            ${memo ? `<span class="text-xs text-gray-500 ml-2 break-words" data-drag-handle="true">[${memo}]</span>` : ''}
                        </div>
                        <span class="text-xs text-gray-400 ml-2 flex-shrink-0" data-drag-handle="true">${flags}</span>
                    </li>`;
                }).join('');

                card.innerHTML = `
                    ${headerHtml}
                    ${driverHtml}
                    <ul id="members-dropzone-${car.id}" class="p-4 space-y-2 min-h-[50px] members-dropzone flex-grow overflow-y-auto" data-drop-type="member">
                        ${membersHtml}
                    </ul>
                `;
                resultsEl.appendChild(card);
            });
        }


        // --- ドラッグ＆ドロップ 統合ロジック ---

        // (共通) ドラッグ開始 (マウス/タッチ)
        function _handleDragStart(targetItem, clientX, clientY) {
            if (!targetItem || isDragging) return false;

            // Ensure we are targeting the LI element
            if (!targetItem.classList.contains('draggable-item')) return false; 
            
            // Allow drag start even if clicking on text inside the handle div
            const targetHandle = targetItem.querySelector('[data-drag-handle="true"]');
            if (!targetHandle && !targetItem.closest('[data-drag-handle="true"]')) return false;

            isDragging = true;
            dragTargetIdInternal = targetItem.dataset.participantId;
            dragSourceCarIdInternal = targetItem.closest('.car-dropzone').dataset.carId;
            dragIsDriverInternal = targetItem.dataset.isDriver === 'true';
            currentDropModeInternal = null;
            currentDropTargetIdInternal = null;

            setTimeout(() => { 
                 const element = document.getElementById(targetItem.id); 
                 if (element) element.classList.add('dragging');
            }, 0);

            if (typeof TouchEvent !== 'undefined' && clientX !== undefined) { 
                createGhostElement(targetItem);
                updateGhostPosition({ clientX, clientY });
            }
            return true;
        }


        // (共通) ドラッグ中 (マウス/タッチ)
        function _handleDragMove(clientX, clientY) {
            if (!isDragging) return;

            if (ghostElement) {
                updateGhostPosition({ clientX, clientY });
                ghostElement.style.visibility = 'hidden';
            }

            const elementUnder = document.elementFromPoint(clientX, clientY);

            if (ghostElement) {
                ghostElement.style.visibility = 'visible';
            }

            updateDropTargetHighlights(elementUnder, clientY);
        }

        // (共通) ドロップ/タッチ終了
        function _handleDrop(targetCarId) { // ★ Receive targetCarId
            if (!isDragging) return;

             // ★ 修正: ローカル変数に現在の状態をコピー
             const localDragTargetId = dragTargetIdInternal;
             const localDragSourceCarId = dragSourceCarIdInternal;
             const localDragIsDriver = dragIsDriverInternal;
             const localCurrentDropMode = currentDropModeInternal;
             const localCurrentDropTargetId = currentDropTargetIdInternal;
            
             performDropOperation(
                 targetCarId, // ★ Pass target car ID received from event handler
                 localDragTargetId,
                 localDragSourceCarId,
                 localDragIsDriver,
                 localCurrentDropMode,
                 localCurrentDropTargetId
             );
            // Cleanup happens in _handleDragEnd
        }

        // (共通) ドラッグ終了/キャンセル (マウス/タッチ)
        function _handleDragEnd() {
            if (!isDragging) return;
            isDragging = false; 

            if (ghostElement) {
                ghostElement.remove();
                ghostElement = null;
            }
            const draggingElement = document.querySelector('.dragging');
            if (draggingElement) {
                draggingElement.classList.remove('dragging');
            }
            clearDragOverHighlights();
            dragTargetIdInternal = null;
            dragSourceCarIdInternal = null;
            dragIsDriverInternal = false;
            currentDropModeInternal = null;
            currentDropTargetIdInternal = null;
            lastTouchMoveClientX = null;
            lastTouchMoveClientY = null;
        }

        // (共通) ハイライト更新とモード設定
        function updateDropTargetHighlights(elementUnder, clientY) {
            const dropzone = elementUnder?.closest('.car-dropzone');
            clearDragOverHighlights(); 
            currentDropModeInternal = null; 
            currentDropTargetIdInternal = null; 

            if (!dropzone || !dragTargetIdInternal) return; 

            const targetCarId = dropzone.dataset.carId;
            const targetCar = currentAssignments.find(c => c.id === targetCarId);
            const sourceCar = currentAssignments.find(c => c.id === dragSourceCarIdInternal); 
            if (!targetCar || !sourceCar) return; 

            const targetItem = elementUnder.closest('.draggable-item');
            const targetDriverZone = elementUnder.closest('.driver-dropzone');
            const targetMembersZone = elementUnder.closest('.members-dropzone');

            const isMovingToDifferentCar = targetCarId !== dragSourceCarIdInternal; 

            // --- Capacity Checks ---
             let isCapacityFullForMove = false;
             if (isMovingToDifferentCar && !dragIsDriverInternal && targetCar.id !== 'excluded-car') { 
                 isCapacityFullForMove = targetCar.members.length >= targetCar.capacity;
             }
             let isCapacityFullForSwap = false;
             if (isMovingToDifferentCar && targetCar.id !== 'excluded-car' && sourceCar.id !== 'excluded-car') {
                 const targetIsDriver = (targetItem && targetItem.dataset.isDriver === 'true') || !!targetDriverZone;
                 if (dragIsDriverInternal && !targetIsDriver && targetCar.members.length >= targetCar.capacity) isCapacityFullForSwap = true; 
                 if (!dragIsDriverInternal && targetIsDriver && sourceCar.members.length >= sourceCar.capacity) isCapacityFullForSwap = true; 
             }
             const isEmptyDriverMoveOverCapacity = isMovingToDifferentCar && !dragIsDriverInternal && targetCar.id !== 'excluded-car' && !targetCar.driver && targetCar.members.length >= targetCar.capacity; 


            // --- Highlight and Mode Logic ---
            if (targetItem) {
                const targetId = targetItem.dataset.participantId;
                if (targetId === dragTargetIdInternal) return; 

                const targetIsDriver = targetItem.dataset.isDriver === 'true';
                if (targetIsDriver || dragIsDriverInternal) { 
                     if (isCapacityFullForSwap) targetItem.classList.add('drop-target-full');
                     else { targetItem.classList.add('drop-target-swap'); currentDropModeInternal = 'swap'; currentDropTargetIdInternal = targetId; } 
                } else {
                    if (isCapacityFullForMove && isMovingToDifferentCar) targetItem.classList.add('drop-target-full');
                    else {
                        const rect = targetItem.getBoundingClientRect(); const midY = rect.top + rect.height / 2;
                        if (clientY < midY) { targetItem.classList.add('drop-target-insert-before'); currentDropModeInternal = 'insert-before'; } 
                        else { targetItem.classList.add('drop-target-insert-after'); currentDropModeInternal = 'insert-after'; } 
                        currentDropTargetIdInternal = targetId; 
                    }
                }
            } else if (targetDriverZone) {
                if (dragIsDriverInternal && targetCarId === dragSourceCarIdInternal) return; 
                if (isCapacityFullForSwap || isEmptyDriverMoveOverCapacity) targetDriverZone.classList.add('drop-target-full');
                else { targetDriverZone.classList.add('drop-target-swap'); currentDropModeInternal = 'swap'; currentDropTargetIdInternal = targetCar?.driver?.id || null; } 
            } else if (targetMembersZone) {
                 if (!dragIsDriverInternal && targetCarId === dragSourceCarIdInternal) return; 
                if (isCapacityFullForMove) targetMembersZone.classList.add('drop-target-full');
                else { targetMembersZone.classList.add('drop-target-move'); currentDropModeInternal = 'move-to-end'; } 
            }
        }
        
        // (共通) ゴースト要素作成
        function createGhostElement(targetElement) {
            if (ghostElement) ghostElement.remove();
            ghostElement = targetElement.cloneNode(true); 
            ghostElement.removeAttribute('id'); 
            ghostElement.classList.remove('dragging'); 
            ghostElement.id = 'ghost-element'; 
            ghostElement.style.position = 'absolute';
            ghostElement.style.zIndex = '1000';
            ghostElement.style.opacity = '0.8';
            ghostElement.style.pointerEvents = 'none';
            ghostElement.style.width = `${targetElement.offsetWidth}px`;
            ghostElement.style.height = `${targetElement.offsetHeight}px`;
            ghostElement.style.backgroundColor = window.getComputedStyle(targetElement).backgroundColor;
            ghostElement.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
            ghostElement.style.padding = '0.5rem'; 
            ghostElement.style.borderRadius = '0.375rem'; 
            document.body.appendChild(ghostElement);
        }

        // (共通) ゴースト要素位置更新
        function updateGhostPosition({ clientX, clientY }) {
            if (!ghostElement) return;
            ghostElement.style.left = `${clientX - ghostElement.offsetWidth / 2}px`;
            ghostElement.style.top = `${clientY - ghostElement.offsetHeight / 2}px`;
        }
        
        // (共通) クリーンアップ
        function handleDragEndCleanup() {
            if (!isDragging) return; 
            isDragging = false; 

            if (ghostElement) {
                ghostElement.remove();
                ghostElement = null;
            }
            const draggingElement = document.querySelector('.dragging');
            if (draggingElement) {
                draggingElement.classList.remove('dragging');
            }
            clearDragOverHighlights();
            dragTargetIdInternal = null;
            dragSourceCarIdInternal = null;
            dragIsDriverInternal = false;
            currentDropModeInternal = null;
            currentDropTargetIdInternal = null;
            lastTouchMoveClientX = null;
            lastTouchMoveClientY = null;
        }

        // ★★★ (共通) ドロップ処理 (データ更新) ★★★
        function performDropOperation(
            targetCarId, // ★ Argument
            pDragTargetId, 
            pDragSourceCarId,
            pDragIsDriver,
            pCurrentDropMode,
            pCurrentDropTargetId
        ) {
             if (document.querySelector('.drop-target-full') || !pCurrentDropMode || !pDragTargetId) {
                if(document.querySelector('.drop-target-full')) showMessage('定員オーバーのため操作できません。', 'error');
                return; 
             }
             if (!targetCarId) return; // Drop outside valid zone

             const sourceCar = currentAssignments.find(c => c.id === pDragSourceCarId);
             const targetCar = currentAssignments.find(c => c.id === targetCarId);
             if (!sourceCar || !targetCar) {
                 console.error("Source or target car not found during drop.");
                 return;
             }

             // --- 操作実行 ---
             const sourceInfo = findAndRemoveParticipantById(pDragSourceCarId, pDragTargetId);
             if (!sourceInfo) {
                 console.error(`Source participant not found during drop: ID=${pDragTargetId}, Car=${pDragSourceCarId}`); // More informative error
                 showMessage('ドラッグ元の参加者が見つかりませんでした。', 'error');
                 return;
             }
             const { participant: sourceParticipant, wasDriver: sourceWasDriver } = sourceInfo;

             let operationSuccessful = false;
             let targetParticipant = null; 
             let targetWasDriver = false;

             try {
                 if (pCurrentDropMode === 'swap') {
                     const targetInfo = findAndRemoveParticipantById(targetCarId, pCurrentDropTargetId);
                     if (targetInfo) {
                         targetParticipant = targetInfo.participant;
                         targetWasDriver = targetInfo.wasDriver;
                     }
                     
                     // ★ Determine role based on where it was dropped (driver zone or driver item)
                     const targetElement = document.getElementById(`p-result-${pCurrentDropTargetId}`) || document.getElementById(`driver-dropzone-${targetCarId}`);
                     const addSourceAsDriverInTarget = targetWasDriver || (targetElement?.closest('.driver-dropzone') && !targetParticipant);

                     addParticipant(targetCar, sourceParticipant, addSourceAsDriverInTarget); 
                     
                     if (targetParticipant) {
                         addParticipant(sourceCar, targetParticipant, sourceWasDriver);
                     }
                     operationSuccessful = true;
                 }
                 else if (pCurrentDropMode === 'insert-before' || pCurrentDropMode === 'insert-after') {
                     const targetIndex = targetCar.members.findIndex(p => p.id === pCurrentDropTargetId);
                     if (targetIndex > -1) {
                         const insertIndex = (pCurrentDropMode === 'insert-before') ? targetIndex : targetIndex + 1;
                         targetCar.members.splice(insertIndex, 0, sourceParticipant);
                         operationSuccessful = true;
                     }
                 }
                 else if (pCurrentDropMode === 'move-to-end') {
                     addParticipant(targetCar, sourceParticipant, false); // Add as passenger
                     operationSuccessful = true;
                 }
             } catch (err) {
                  console.error("Error during drop operation:", err);
             }

             // --- 後処理 ---
             if (!operationSuccessful) {
                 addParticipant(sourceCar, sourceParticipant, sourceWasDriver); // Revert source
                 if (pCurrentDropMode === 'swap' && targetParticipant) { // Revert target if swapped
                     addParticipant(targetCar, targetParticipant, targetWasDriver);
                 }
                 if (!document.querySelector('.drop-target-full')) { 
                     showMessage('操作に失敗しました。', 'error');
                 }
             } else {
                  // Promote driver if needed
                  [sourceCar, targetCar].filter((car, index, self) => car && self.findIndex(c => c.id === car.id) === index) 
                      .forEach(car => {
                          if (car.id !== 'excluded-car' && !car.driver && car.members.length > 0) {
                              car.driver = car.members.shift();
                          }
                      });
                 hideMessage();
             }

             renderResults(currentAssignments);
             updateTextOutput();
        }

        // (共通) ヘルパー: IDで参加者を探して削除
        function findAndRemoveParticipantById(carId, pId) {
            const car = currentAssignments.find(c => c.id === carId);
            if (!car || !pId) {
                 // console.warn(`findAndRemoveParticipantById: Car (${carId}) or Participant ID (${pId}) is invalid.`);
                return null;
            }
            if (car.driver && car.driver.id === pId) {
                const p = car.driver; car.driver = null; 
                return { participant: p, wasDriver: true };
            }
            const index = car.members.findIndex(p => p.id === pId);
            if (index > -1) {
                const p = car.members.splice(index, 1)[0]; 
                return { participant: p, wasDriver: false };
            }
            // console.warn(`Participant ${pId} not found in car ${carId} for removal.`);
            return null;
        }

        // (共通) ヘルパー: 参加者を追加
        function addParticipant(car, participant, isDriver = false) {
             if (!car || !participant) return;
             if (typeof participant !== 'object' || participant === null || !participant.id) {
                console.error("Invalid participant object:", participant); return;
             }
             if (car.id === 'excluded-car') {
                 if (!car.members.some(m => m.id === participant.id)) car.members.push(participant);
                 return;
             }
             // Add as driver if specified or if driver slot is empty
             if ((isDriver || !car.driver) && car.id !== 'excluded-car') {
                 // If there's already a driver AND it's not the same person we're adding, demote current driver
                 if (car.driver && car.driver.id !== participant.id) {
                     car.members.unshift(car.driver);
                 }
                 // Avoid setting self as driver if already a member
                 const existingMemberIndex = car.members.findIndex(m => m.id === participant.id);
                 if (existingMemberIndex > -1) car.members.splice(existingMemberIndex, 1);

                 car.driver = participant;
             } else {
                 // Add as passenger, avoid duplicates
                  if (!car.members.some(m => m.id === participant.id) && (!car.driver || car.driver.id !== participant.id)) {
                      car.members.push(participant);
                  }
             }
        }

        // --- マウスイベントラッパー ---
        function handleDragStart(e) { 
            _handleDragStart(e.target.closest('.draggable-item'), e.clientX, e.clientY)
            // No preventDefault needed for dragstart to allow dataTransfer
        }
        function handleDragOver(e) { e.preventDefault(); _handleDragMove(e.clientX, e.clientY); }
        function handleDrop(e) { 
            e.preventDefault(); 
            // Pass target car ID explicitly
            const targetCarId = e.target.closest('.car-dropzone')?.dataset.carId;
             _handleDrop(targetCarId); // ★ Pass targetCarId
        }
        function handleDragEnd(e) { _handleDragEnd(); } 

        // --- タッチイベントラッパー ---
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                 if(_handleDragStart(e.target.closest('.draggable-item'), e.touches[0].clientX, e.touches[0].clientY)) {
                     e.preventDefault(); // Prevent scroll only if drag started
                 }
            }
        }
        function handleTouchMove(e) {
            if (e.touches.length === 1 && isDragging) {
                 e.preventDefault(); 
                 lastTouchMoveClientX = e.touches[0].clientX;
                 lastTouchMoveClientY = e.touches[0].clientY;
                 _handleDragMove(lastTouchMoveClientX, lastTouchMoveClientY);
            }
        }
        function handleTouchEnd(e) {
            if (isDragging) {
                 // Pass target car ID explicitly
                 let targetCarId = null;
                 const touch = e.changedTouches[0]; 
                 if (touch) {
                     let elementUnderFinger = null;
                     if (ghostElement) ghostElement.style.visibility = 'hidden';
                     elementUnderFinger = document.elementFromPoint(touch.clientX, touch.clientY);
                     if (ghostElement) ghostElement.style.visibility = 'visible';
                     targetCarId = elementUnderFinger?.closest('.car-dropzone')?.dataset.carId;
                 }
                 _handleDrop(targetCarId); // ★ Pass targetCarId
                 _handleDragEnd(); 
            }
        }


        // --- 他のイベントハンドラ ---
        function handleParticipantChange(e) { 
             const target = e.target; if (target.type === 'checkbox' && target.dataset.action === 'select-participant') { const id = target.dataset.id; const dataEl = document.getElementById(`data-inputs-${id}`); if (target.checked) { selectedParticipantIds.add(id); if (dataEl) { dataEl.classList.remove('opacity-50'); dataEl.querySelectorAll('input, textarea').forEach(input => input.disabled = false); } } else { selectedParticipantIds.delete(id); if (dataEl) { dataEl.classList.add('opacity-50'); dataEl.querySelectorAll('input, textarea').forEach(input => input.disabled = true); } if (excludedParticipantIds.has(id)) { excludedParticipantIds.delete(id); } } renderExclusionList(); }
        }
        function handleParticipantDataInput(e) { 
             const target = e.target; if (target.dataset.id && target.dataset.type) { const id = target.dataset.id; const type = target.dataset.type; const value = target.value; const data = participantData.get(id) || { grade: '', school: '', other: '', memo: '' }; data[type] = value; participantData.set(id, data); }
        }
        function handleCarChange(e) { 
            const target = e.target; const carId = target.closest('[data-car-id]')?.dataset.carId; if (!carId) return; const action = target.dataset.action; if (action === 'select-car') { if (target.checked) { selectedCarIds.add(carId); document.getElementById(`car-options-${carId}`)?.classList.remove('hidden'); } else { selectedCarIds.delete(carId); selectedLuggage.delete(carId); document.getElementById(`car-options-${carId}`)?.classList.add('hidden'); } } else if (action === 'select-driver') { if (target.value) { selectedDrivers.set(carId, target.value); } else { selectedDrivers.delete(carId); } } else if (action === 'select-luggage') { if (target.checked) { selectedLuggage.add(carId); } else { selectedLuggage.delete(carId); } }
        }
        function handleExclusionChange(e) { 
            const target = e.target; if (target.type === 'checkbox' && target.dataset.action === 'exclude-participant') { const id = target.dataset.id; if (target.checked) { excludedParticipantIds.add(id); } else { excludedParticipantIds.delete(id); } }
        }
        function handleAssignment() { 
             if (selectedCarIds.size === 0) { showMessage('ステップ2で車を1台以上選択してください。', 'error'); return; } let errors = []; let driverMap = new Map(); let selectedCarsData = []; const allParticipantsWithData = ALL_PARTICIPANTS_FLAT .filter(p => selectedParticipantIds.has(p.id)) .map(p => { const family = FAMILIES.find(f => f.members.some(m => m.id === p.id)); const currentData = participantData.get(p.id) || {}; const masterData = p.data || {}; return { ...p, grade: currentData.grade !== undefined ? currentData.grade : masterData.grade || '', school: currentData.school !== undefined ? currentData.school : masterData.school || '', other: currentData.other !== undefined ? currentData.other : masterData.other || '', memo: currentData.memo !== undefined ? currentData.memo : masterData.memo || '', familyName: family ? family.familyName : null }; }); selectedCarIds.forEach(carId => { const driverId = selectedDrivers.get(carId); const carInfo = AVAILABLE_CARS_INFO.find(c=>c.id === carId); if (!carInfo) return; if (!driverId) { errors.push(`${carInfo.name} のドライバーが選択されていません。`); return; } const driver = allParticipantsWithData.find(p => p.id === driverId); if (!driver) { const masterDriverInfo = ALL_PARTICIPANTS_FLAT.find(p=>p.id === driverId); if (masterDriverInfo) { errors.push(`ドライバー (${masterDriverInfo.name}) が参加者に含まれていません。`); } else { errors.push(`${carInfo.name} のドライバー(ID: ${driverId})が見つかりません。`); } return; } if (Array.from(driverMap.values()).some(d => d.id === driverId)) { errors.push(`ドライバー (${driver.name}) が複数の車に割り当てられています。`); } driverMap.set(carId, driver); const hasLuggage = selectedLuggage.has(carId); let actualCapacity = carInfo.baseCapacity - 1; if (hasLuggage) actualCapacity = 1; selectedCarsData.push({ id: carId, name: carInfo.name, familyName: carInfo.familyName, driverId: driverId, capacity: actualCapacity, hasLuggage: hasLuggage }); }); if (errors.length > 0) { showMessage(errors.join('<br>'), 'error'); return; } const driverIds = new Set(Array.from(driverMap.values()).map(d => d.id)); let participantsToAssign = allParticipantsWithData.filter(p => !driverIds.has(p.id) && !excludedParticipantIds.has(p.id) ); let excludedParticipants = allParticipantsWithData.filter(p => excludedParticipantIds.has(p.id) && !driverIds.has(p.id) ); const totalParticipants = participantsToAssign.length; const totalCapacity = selectedCarsData.reduce((sum, car) => sum + car.capacity, 0); if (totalParticipants > totalCapacity) { showMessage(`定員オーバーです。乗客 ${totalParticipants}人 に対して定員は合計 ${totalCapacity}人 です。`, 'warning'); } else { hideMessage(); } const assignments = allocateParticipants(participantsToAssign, selectedCarsData, driverMap); assignments.push({ id: 'excluded-car', name: '別便', capacity: 999, driver: null, members: excludedParticipants, hasLuggage: false }); currentAssignments = assignments; renderResults(currentAssignments); currentAssignments.forEach(car => { car.element = document.getElementById(`car-result-${car.id}`); }); updateTextOutput();
        }
        function allocateParticipants(participants, cars, driverMap){ 
             let assignments = cars.map(car => ({ ...car, driver: driverMap.get(car.id) || null, members: [] })); if (participants.length === 0) return assignments; let remainingParticipants = [...participants]; const typePriority = { '保護者': 1, '兄弟': 2, '選手': 3, 'その他': 4 }; assignments.forEach(car => { if (!car.driver || !car.familyName || car.driver.familyName !== car.familyName) return; let familyMembers = remainingParticipants .filter(p => p.familyName === car.familyName) .sort((a, b) => (typePriority[a.type] || 9) - (typePriority[b.type] || 9)); familyMembers.forEach(member => { if (car.members.length < car.capacity) { car.members.push(member); remainingParticipants = remainingParticipants.filter(p => p.id !== member.id); } }); }); function getFlagMatchScore(pA, pB) { if (!pA || !pB || !pA.isFlagTarget || !pB.isFlagTarget) return 0; let score = 0; if (pA.grade && pA.grade === pB.grade) score++; if (pA.school && pA.school === pB.school) score++; if (pA.other && pA.other === pB.other) score++; return score; } let participantsToProcess = remainingParticipants.sort((a, b) => (a.isFlagTarget !== b.isFlagTarget) ? (a.isFlagTarget ? -1 : 1) : Math.random() - 0.5); let stillRemaining = []; participantsToProcess.forEach(participant => { let bestCarCandidates = []; let maxScore = 0; assignments.forEach(car => { if (car.members.length >= car.capacity) return; let currentCarScore = car.members.reduce((score, member) => score + getFlagMatchScore(participant, member), 0); if (currentCarScore > maxScore) { maxScore = currentCarScore; bestCarCandidates = [car]; } else if (currentCarScore > 0 && currentCarScore === maxScore) { bestCarCandidates.push(car); } }); if (bestCarCandidates.length > 0) { const bestCar = bestCarCandidates[Math.floor(Math.random() * bestCarCandidates.length)]; bestCar.members.push(participant); } else { stillRemaining.push(participant); } }); if (stillRemaining.length > 0) { let carsWithVacancy = assignments.map(car => ({ carRef: car, vacancy: car.capacity - car.members.length })).filter(c => c.vacancy > 0).sort((a, b) => b.vacancy - a.vacancy); let carIndex = 0; stillRemaining.forEach(participant => { if (carsWithVacancy.length === 0) return; let assigned = false, initialCarIndex = carIndex; while(!assigned) { if (carsWithVacancy.length === 0) break; carIndex = carIndex % carsWithVacancy.length; const targetCarInfo = carsWithVacancy[carIndex]; if (targetCarInfo.carRef.members.length < targetCarInfo.carRef.capacity) { targetCarInfo.carRef.members.push(participant); targetCarInfo.vacancy--; assigned = true; if (targetCarInfo.vacancy <= 0) carsWithVacancy.splice(carIndex, 1); else carIndex++; } else { carsWithVacancy.splice(carIndex, 1); } if (carsWithVacancy.length > 0 && carIndex % carsWithVacancy.length === initialCarIndex && !assigned) break; } }); } return assignments;
        }
        function handleToggleDetails(){ 
             const detailsElements = participantListEl.querySelectorAll('details'); const shouldOpen = toggleDetailsButton.textContent === 'すべて開く'; detailsElements.forEach(details => { details.open = shouldOpen; }); toggleDetailsButton.textContent = shouldOpen ? 'すべて閉じる' : 'すべて開く';
        }
        function showMessage(message, type = 'info'){ 
             messageText.innerHTML = message; messageContainer.className = 'p-4 mb-4 border rounded-lg'; switch(type) { case 'error': messageContainer.classList.add('bg-red-100', 'border-red-400', 'text-red-700'); break; case 'warning': messageContainer.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700'); break; default: messageContainer.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700'); }
        }
        function hideMessage(){ 
             messageContainer.classList.add('hidden');
        }
        function getCurrentState(){ 
             return { selectedParticipantIds: Array.from(selectedParticipantIds), selectedCarIds: Array.from(selectedCarIds), selectedDrivers: Array.from(selectedDrivers.entries()), selectedLuggage: Array.from(selectedLuggage), excludedParticipantIds: Array.from(excludedParticipantIds), participantData: Array.from(participantData.entries()) };
        }
        function restoreState(state){ 
             selectedParticipantIds = new Set(state.selectedParticipantIds || []); selectedCarIds = new Set(state.selectedCarIds || []); selectedDrivers = new Map(state.selectedDrivers || []); selectedLuggage = new Set(state.selectedLuggage || []); excludedParticipantIds = new Set(state.excludedParticipantIds || []); participantData = new Map(state.participantData || []); if (participantData.size === 0) { initializeParticipantData(); } currentAssignments = [];
        }
        function handleExportState(){ 
             const state = getCurrentState(); const jsonString = JSON.stringify(state, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `car_assignment_state_${new Date().toISOString().slice(0,10)}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showMessage('現在の状態をファイルに保存しました。', 'info');
        }
        function handleImportState(e){ 
             const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { try { const state = JSON.parse(event.target.result); restoreState(state); renderParticipantList(); renderCarList(); renderExclusionList(); renderResults([]); textOutputContainer.classList.add('hidden'); showMessage('状態を読み込みました。', 'info'); } catch (err) { console.error('Error parsing JSON state:', err); showMessage('ファイルの読み込みに失敗しました。無効なJSONファイルです。', 'error'); } e.target.value = null; }; reader.readAsText(file);
        }
        function handleShowTextOutput(){ 
              if (currentAssignments.length === 0) { showMessage('テキスト出力する結果がありません。先に「割り当て実行」を押してください。', 'error'); return; } textOutputContainer.classList.toggle('hidden'); if (!textOutputContainer.classList.contains('hidden')) { updateTextOutput(); }
        }
        function updateTextOutput(){ 
             if (currentAssignments.length === 0) { textOutputEl.value = ''; return; } const carLines = currentAssignments.filter(car => car.id !== 'excluded-car').map(car => { const carName = car.name.replace(/の車|家の車/g, 'カー'); let driverName = ' (ドライバー未定)'; if (car.driver) { const memo = (participantData.get(car.driver.id)?.memo || '').trim(); driverName = car.driver.name + (memo ? ` [${memo}]` : ''); } const members = car.members.map(p => { let name = p.name; if (p.type === '選手') name = '★' + name; const memo = (participantData.get(p.id)?.memo || '').trim(); return name + (memo ? ` [${memo}]` : ''); }); const luggage = car.hasLuggage ? '荷物' : null; const parts = [driverName, ...members]; if (luggage) parts.push(luggage); return `${carName} (${parts.join(', ')})`; }); const excludedCar = currentAssignments.find(car => car.id === 'excluded-car'); let excludedLines = []; if (excludedCar && excludedCar.members.length > 0) { excludedLines.push('-------'); excludedLines.push('□別便'); excludedCar.members.forEach(p => { let name = p.name; if (p.type === '選手') name = '★' + name; const memo = (participantData.get(p.id)?.memo || '').trim(); excludedLines.push(name + (memo ? ` [${memo}]` : '')); }); } textOutputEl.value = [...carLines, ...excludedLines].join('\n');
        }
        function handleCopyTextOutput(){ 
              if (!textOutputEl.value) return; try { navigator.clipboard.writeText(textOutputEl.value).then(() => { showMessage('クリップボードにコピーしました。', 'info'); }, (err) => { legacyCopy(textOutputEl.value); }); } catch (err) { legacyCopy(textOutputEl.value); }
        }
        function legacyCopy(text){ 
              const textArea = document.createElement('textarea'); textArea.value = text; textArea.style.position = 'fixed'; textArea.style.opacity = '0'; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { const successful = document.execCommand('copy'); if (successful) { showMessage('クリップボードにコピーしました。', 'info'); } else { showMessage('コピーに失敗しました。', 'error'); } } catch (err) { showMessage('コピーに失敗しました。', 'error'); } document.body.removeChild(textArea);
        }
        function handleExportMasterData(){ 
              const masterData = { families: FAMILIES, cars: AVAILABLE_CARS_INFO }; const jsonString = JSON.stringify(masterData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `car_assignment_master_${new Date().toISOString().slice(0,10)}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showMessage('現在のマスターデータをファイルに保存しました。', 'info');
        }
        function handleImportMasterData(e){ 
              const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { try { const masterData = JSON.parse(event.target.result); if (!masterData || !Array.isArray(masterData.families) || !Array.isArray(masterData.cars)) { throw new Error('JSONの形式が正しくありません。 "families" と "cars" の配列が必要です。'); } FAMILIES = masterData.families; AVAILABLE_CARS_INFO = masterData.cars; ALL_PARTICIPANTS_FLAT = FAMILIES.flatMap(f => f.members); restoreState({}); initializeParticipantData(); renderParticipantList(); renderCarList(); renderExclusionList(); renderResults([]); textOutputContainer.classList.add('hidden'); toggleDetailsButton.textContent = 'すべて閉じる'; showMessage('マスターデータを読み込み、アプリをリセットしました。', 'info'); } catch (err) { console.error('Error parsing master data JSON:', err); showMessage(`マスターデータの読み込みに失敗しました: ${err.message}`, 'error'); } e.target.value = null; }; reader.readAsText(file);
        }

    </script>

</body>
</html>

