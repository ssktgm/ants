<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配車調整アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ドラッグ中の要素のスタイル */
        .opacity-50 { opacity: 0.5; }
        
        /* ドラッグ可能なアイテム */
        .draggable-item {
            cursor: move;
            /* ★タッチ操作時にテキスト選択が起こらないようにする */
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
        }

        /* ★ドロップ先(移動)のハイライト */
        .members-dropzone.drop-target-move { 
            background-color: #EFF6FF; 
        }
        
        /* ★ドロップ先(入れ替え)のハイライト */
        .driver-dropzone.drop-target-swap, .draggable-item.drop-target-swap {
            border: 2px dashed #3B82F6; /* blue-500 */
            box-shadow: 0 0 5px rgba(59, 130, 246, 0.5);
        }
        
        /* ★ドロップ先(挿入)のハイライト */
        .draggable-item.drop-target-insert-before {
            border-top: 3px solid #3B82F6; /* blue-500 */
        }
        .draggable-item.drop-target-insert-after {
            border-bottom: 3px solid #3B82F6; /* blue-500 */
        }

        /* ★ドロップ先(定員オーバー) */
        .members-dropzone.drop-target-full, .driver-dropzone.drop-target-full { 
            background-color: #FEF2F2; 
        }
        
        /* details[open] summary のスタイル */
        details[open] > summary {
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
        }
        /* ファイル入力ボタンを隠す */
        #import-state-input, #import-master-input {
            display: none;
        }

        /* 可変グリッドレイアウトのためのCSS */
        .main-grid-layout {
            display: grid;
            grid-template-columns: repeat(1, minmax(0, 1fr)); /* default: 1 col */
            gap: 1.5rem; /* gap-6 */
        }
        
        /* 結果表示用のグリッドレイアウト */
        .results-grid-layout {
            display: grid;
            grid-template-columns: repeat(1, minmax(0, 1fr)); /* default: 1 col */
            gap: 1rem; /* gap-4 */
        }

        @media (min-width: 768px) { /* md: breakpoint */
            .main-grid-layout {
                /* JSからこの変数を変更できるようにする */
                grid-template-columns: repeat(var(--layout-columns, 3), minmax(0, 1fr));
            }
            
            /* 結果表示用のグリッド（MD以上） */
            .results-grid-layout {
                grid-template-columns: repeat(var(--layout-columns, 3), minmax(0, 1fr));
            }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">配車調整アプリ</h1>

        <!-- ファイル入出力ボタン -->
        <section class="mb-6 grid grid-cols-2 gap-2 max-w-md">
            <!-- 状態 -->
            <button id="export-state-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-200">
                状態を保存 (JSON)
            </button>
            <label for="import-state-input" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-200 cursor-pointer text-center">
                状態を読み込む (JSON)
            </label>
            <input type="file" id="import-state-input" accept=".json">

            <!-- マスターデータ -->
            <button id="export-master-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-200">
                マスターを保存 (JSON)
            </button>
            <label for="import-master-input" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-200 cursor-pointer text-center">
                マスターを読み込む (JSON)
            </label>
            <input type="file" id="import-master-input" accept=".json">
        </section>


        <!-- メッセージエリア -->
        <div id="message" class="hidden p-4 mb-4 border rounded-lg" role="alert">
            <span id="message-text"></span>
            <button id="message-close" type="button" class="float-right font-bold text-lg leading-none">&times;</button>
        </div>

        <!-- メインコンテンツグリッド -->
        <div id="main-content" class="main-grid-layout">

            <!-- ステップ 1: 参加者選択 -->
            <section>
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-gray-700">1. 参加者を選択</h2>
                    <button id="toggle-details-button" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-1 px-3 rounded-lg text-sm transition duration-200">
                        すべて閉じる
                    </button>
                </div>
                <div id="participant-list" class="space-y-2 h-[600px] overflow-y-auto bg-white p-4 rounded-lg shadow">
                    <!-- JSで描画 -->
                </div>
            </section>

            <!-- ステップ 2: 車選択 -->
            <section>
                <h2 class="text-xl font-semibold text-gray-700 mb-3">2. 車とドライバーを選択</h2>
                <div id="car-list" class="space-y-3 h-[600px] overflow-y-auto bg-white p-4 rounded-lg shadow">
                    <!-- JSで描画 -->
                </div>
            </section>

            <!-- ステップ 3 & 4: 別便除外 と 実行ボタン -->
            <section>
                <h2 class="text-xl font-semibold text-gray-700 mb-3">3. 別便の人を除外</h2>
                <div id="exclusion-list" class="space-y-2 h-[488px] overflow-y-auto bg-white p-4 rounded-lg shadow min-h-[50px]">
                    <!-- JSで描画 -->
                </div>
                
                <div class="mt-6 text-center">
                    <button id="assign-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-10 rounded-lg shadow-lg transition duration-200 ease-in-out transform hover:scale-105">
                        4. 割り当て実行
                    </button>
                </div>
            </section>

            <!-- ステップ 5: 割り当て結果 -->
            <section id="results-section" class="md:col-span-3"> 
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-gray-700">5. 割り当て結果 (ドラッグ＆ドロップで調整可能)</h2>
                    <button id="show-text-output-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-1 px-3 rounded-lg shadow text-sm transition duration-200">
                        テキスト出力
                    </button>
                </div>

                <!-- テキスト出力エリア -->
                <div id="text-output-container" class="mb-4 hidden">
                    <textarea id="text-output" rows="10" class="w-full p-2 border rounded-lg font-mono text-sm bg-gray-50" readonly></textarea>
                    <button id="copy-text-output-button" class="mt-2 bg-gray-400 hover:bg-gray-500 text-white py-1 px-3 rounded text-sm">
                        コピー
                    </button>
                </div>

                <div id="results" class="results-grid-layout"> 
                    <p id="results-placeholder" class="text-gray-500 text-sm bg-white p-4 rounded-lg shadow min-h-[50px] md:col-span-3">ステップ4の「割り当て実行」を押してください。</p>
                </div>
            </section>

        </div> <!-- main-content 閉じタグ -->

    </div>

    <script type="module">
        // --- レイアウト列数の定義 ---
        const LAYOUT_COLUMNS = 3; 

        // --- 事前定義データ ---
        
        let FAMILIES = [
            {
                familyName: '小高家', 
                members: [
                    { id: 'p1', name: '斗愛', type: '選手', isFlagTarget: true, data: { grade: '5年', school: '東小', other: '', memo: '' } },
                    { id: 'p2', name: '小高監督', type: '保護者', data: { memo: '' } },
                    { id: 'p3', name: '小高母', type: '保護者', data: { memo: '' } },
                    { id: 'p22', name: '愛之佑', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '東小', other: '', memo: '' } } 
                ]
            },
            {
                familyName: '難波家',
                members: [
                    { id: 'p4', name: '諒成', type: '選手', isFlagTarget: true, data: { grade: '5年', school: 'x小', other: '', memo: '' } },
                    { id: 'p5', name: '難波父', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: '浪川家',
                members: [
                    { id: 'p6', name: '長政', type: '選手', isFlagTarget: true, data: { grade: '5年', school: '小金小', other: '', memo: '' } },
                    { id: 'p7', name: '浪川父', type: '保護者', data: { memo: '' } },
                    { id: 'p8', name: '浪川母', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: '高橋家',
                members: [
                    { id: 'p9', name: '湊多', type: '選手', isFlagTarget: true, data: { grade: '5年', school: '東小', other: '', memo: '' } }
                ]
            },
            {
                familyName: '山田家',
                members: [
                    { id: 'p10', name: '颯真', type: '選手', isFlagTarget: true, data: { grade: '4年', school: '小金小', other: '', memo: '' } },
                    { id: 'p11', name: '山田父', type: '保護者', data: { memo: '' } },
                    { id: 'p12', name: '山田母', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: '菱沼家',
                members: [
                    { id: 'p13', name: '颯介', type: '選手', isFlagTarget: true, data: { grade: '4年', school: '小金小', other: '', memo: '' } },
                    { id: 'p14', name: '菱沼父', type: '保護者', data: { memo: '' } },
                    { id: 'p15', name: '菱沼母', type: '保護者', data: { memo: '' } },
                    { id: 'p16', name: 'つぐみ', type: '兄弟', isFlagTarget: false, data: { grade: '2年', school: '小金小', other: '', memo: '' } }
                ]
            },
            {
                familyName: '小野家',
                members: [
                    { id: 'p17', name: '暁人', type: '選手', isFlagTarget: true, data: { grade: '4年', school: '小金小', other: '', memo: '' } },
                    { id: 'p18', name: '小野母', type: '保護者', data: { memo: '' } },
                    { id: 'p19', name: 'ななか', type: '兄弟', isFlagTarget: true, data: { grade: '2年', school: '小金小', other: '', memo: '' } }
                ]
            },
            {
                familyName: '津村家',
                members: [
                    { id: 'p20', name: '一樹', type: '選手', isFlagTarget: true, data: { grade: '4年', school: '東小', other: '', memo: '' } },
                    { id: 'p21', name: '津村父', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: '浅野家',
                members: [
                    { id: 'p23', name: '泰地', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '小金小', other: '', memo: '' } },
                    { id: 'p24', name: '浅野父', type: '保護者', data: { memo: '' } },
                    { id: 'p25', name: '浅野母', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: '近藤家', 
                members: [
                    { id: 'p26', name: '謙成', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '八木南小', other: '', memo: '' } },
                    { id: 'p44', name: '茉莉', type: '選手', isFlagTarget: true, data: { grade: '1年', school: '八木南小', other: '', memo: '' } } ,
                    { id: 'p27', name: '近藤父', type: '保護者', data: { memo: '' } },
                    { id: 'p28', name: '近藤母', type: '保護者', data: { memo: '' } },
                    { id: 'p29', name: 'おうすけ', type: '兄弟', isFlagTarget: true, data: { grade: '', school: '', other: '', memo: '' } }
                ]
            },
            {
                familyName: '知野見家',
                members: [
                    { id: 'p30', name: '怜央', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '小金小', other: '', memo: '' } },
                    { id: 'p31', name: '知野見父', type: '保護者', data: { memo: '' } },
                    { id: 'p32', name: '知野見母', type: '保護者', data: { memo: '' } },
                    { id: 'p33', name: 'ゆな', type: '兄弟', isFlagTarget: true, data: { grade: '', school: '', other: '', memo: '' } }
                ]
            },
            {
                familyName: '藤山家',
                members: [
                    { id: 'p34', name: '琉杜', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '小金小', other: '', memo: '' } },
                    { id: 'p35', name: '藤山父', type: '保護者', data: { memo: '' } },
                    { id: 'p36', name: '藤山母', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: '小河原家',
                members: [
                    { id: 'p37', name: '維', type: '選手', isFlagTarget: true, data: { grade: '3年', school: '小金小', other: '', memo: '' } }, // 画像では 3年 A/B
                    { id: 'p38', name: '小河原父', type: '保護者', data: { memo: '' } },
                    { id: 'p39', name: '小河原母', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: '古川家',
                members: [
                    { id: 'p40', name: '峻丞', type: '選手', isFlagTarget: true, data: { grade: '2年', school: '新松戸南小', other: '', memo: '' } },
                    { id: 'p41', name: '古川父', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: '坪井家',
                members: [
                    { id: 'p42', name: '雄也', type: '選手', isFlagTarget: true, data: { grade: '1年', school: '東小', other: '', memo: '' } },
                    { id: 'p43', name: '坪井父', type: '保護者', data: { memo: '' } }
                ]
            },
            {
                familyName: 'スタッフ・個人', // ★コーチ等、家族に属さない個人用
                members: [
                    { id: 'p94', name: '渡邉会長', type: 'その他', data: { memo: '' } },
                    { id: 'p99', name: '木村代表', type: 'その他', data: { memo: '' } },
                    { id: 'p98', name: '吉田さん', type: 'その他', data: { memo: '' } },
                    { id: 'p97', name: '前田さん', type: 'その他', data: { memo: '' } },
                    { id: 'p96', name: '中田さん', type: 'その他', data: { memo: '' } },
                    { id: 'p95', name: '渡辺さん', type: 'その他', data: { memo: '' } },
                ]
            }
        ];

        let AVAILABLE_CARS_INFO = [
            { id: 'c1', name: '小高カー', familyName: '小高家', baseCapacity: 6 }, 
            { id: 'c2', name: '難波カー', familyName: '難波家', baseCapacity: 7 },
            { id: 'c3', name: '浪川カー①', familyName: '浪川家', baseCapacity: 6 },
            { id: 'c4', name: '浪川カー②', familyName: '浪川家', baseCapacity: 5 },
            { id: 'c5', name: '山田カー①', familyName: '山田家', baseCapacity: 7 },
            { id: 'c6', name: '山田カー②', familyName: '山田家', baseCapacity: 5 },
            { id: 'c7', name: '菱沼カー', familyName: '菱沼家', baseCapacity: 6 },
            { id: 'c8', name: '小野カー', familyName: '小野家', baseCapacity: 8 },
            { id: 'c9', name: '浅野カー', familyName: '浅野家', baseCapacity: 8 },
            { id: 'c10', name: '近藤カー', familyName: '近藤家', baseCapacity: 6 }, 
            { id: 'c11', name: '知野見カー', familyName: '知野見家', baseCapacity: 7 }, // ※画像に定員記載なし、仮に7
            { id: 'c12', name: '藤山カー', familyName: '藤山家', baseCapacity: 4 },
            { id: 'c13', name: '小河原カー①', familyName: '小河原家', baseCapacity: 4 },
            { id: 'c14', name: '小河原カー②', familyName: '小河原家', baseCapacity: 4 },
            { id: 'c15', name: '古川カー', familyName: '古川家', baseCapacity: 8 },
            { id: 'c16', name: 'コーチカー', familyName: 'スタッフ・個人', baseCapacity: 5 } // ★コーチ用の車（仮）
        ];

        let ALL_PARTICIPANTS_FLAT = FAMILIES.flatMap(f => f.members);


        // --- 状態変数 ---
        let selectedParticipantIds = new Set();
        let selectedCarIds = new Set();
        let selectedDrivers = new Map(); // carId -> driverId
        let selectedLuggage = new Set(); // carId
        let excludedParticipantIds = new Set();
        let participantData = new Map(); // participantId -> { grade, school, other, memo }
        let currentAssignments = []; // 割り当て結果: { car..., driver: {p...}, members: [{p...}] }
        
        // ドラッグ＆ドロップ用一時変数
        let dragTargetId = null; 
        let dragSourceCarId = null; 
        let dragIsDriver = false;
        let currentDropMode = null; // 'swap', 'insert-before', 'insert-after', 'move-to-end'
        let currentDropTargetId = null; // 挿入/スワップ対象のID

        // ★タッチ操作用
        let ghostElement = null;
        let lastTouchMoveEvent = null; // touchmoveイベントを保持


        // --- DOM参照 ---
        const participantListEl = document.getElementById('participant-list');
        const carListEl = document.getElementById('car-list');
        const exclusionListEl = document.getElementById('exclusion-list');
        const resultsEl = document.getElementById('results');
        const assignButton = document.getElementById('assign-button');
        const messageContainer = document.getElementById('message');
        const messageText = document.getElementById('message-text');
        const messageClose = document.getElementById('message-close');
        const exportButton = document.getElementById('export-state-button');
        const importInput = document.getElementById('import-state-input');
        const showTextOutputButton = document.getElementById('show-text-output-button');
        const textOutputContainer = document.getElementById('text-output-container');
        const textOutputEl = document.getElementById('text-output');
        const copyTextOutputButton = document.getElementById('copy-text-output-button');
        const toggleDetailsButton = document.getElementById('toggle-details-button');
        
        const exportMasterButton = document.getElementById('export-master-button');
        const importMasterInput = document.getElementById('import-master-input');


        // --- 初期化処理 ---
        document.addEventListener('DOMContentLoaded', () => {
            // CSS変数をJSから設定
            document.documentElement.style.setProperty('--layout-columns', LAYOUT_COLUMNS);
            
            // 結果セクションの列スパンを動的に調整
            const resultsSection = document.getElementById('results-section');
            const mainContent = document.getElementById('main-content');
            
            function updateLayouts() { 
                const placeholder = document.getElementById('results-placeholder');
                
                // MD (768px) 以上でグリッドレイアウトを適用
                if (window.innerWidth >= 768) { 
                    resultsSection.style.gridColumn = `span ${LAYOUT_COLUMNS}`;
                    if (placeholder) {
                        placeholder.style.gridColumn = `span ${LAYOUT_COLUMNS}`;
                    }
                } else {
                    resultsSection.style.gridColumn = 'auto';
                    if (placeholder) {
                        placeholder.style.gridColumn = 'auto';
                    }
                }
            }
            updateLayouts();
            window.addEventListener('resize', updateLayouts); 

            initializeParticipantData(); 
            renderParticipantList();
            renderCarList();
            
            participantListEl.addEventListener('change', handleParticipantChange);
            participantListEl.addEventListener('input', handleParticipantDataInput); 
            participantListEl.addEventListener('click', handleFamilyCheck); // ★一括チェック用
            carListEl.addEventListener('change', handleCarChange);
            exclusionListEl.addEventListener('change', handleExclusionChange);
            assignButton.addEventListener('click', handleAssignment);
            messageClose.addEventListener('click', hideMessage);

            // 標準ドラッグイベント
            resultsEl.addEventListener('dragstart', handleDragStart);
            resultsEl.addEventListener('dragover', handleDragOver);
            resultsEl.addEventListener('drop', handleDrop);
            resultsEl.addEventListener('dragend', handleDragEnd);
            resultsEl.addEventListener('dragleave', handleDragLeave); // ★ハイライト消去用

            // ★タッチイベントリスナーを追加 (passive: false で preventDefault を許可)
            resultsEl.addEventListener('touchstart', handleTouchStart, { passive: false });
            resultsEl.addEventListener('touchmove', handleTouchMove, { passive: false });
            resultsEl.addEventListener('touchend', handleTouchEnd);
            resultsEl.addEventListener('touchcancel', handleTouchCancel); // ★キャンセル用
            
            exportButton.addEventListener('click', handleExportState);
            importInput.addEventListener('change', handleImportState);
            showTextOutputButton.addEventListener('click', handleShowTextOutput);
            copyTextOutputButton.addEventListener('click', handleCopyTextOutput);
            toggleDetailsButton.addEventListener('click', handleToggleDetails);

            exportMasterButton.addEventListener('click', handleExportMasterData);
            importMasterInput.addEventListener('change', handleImportMasterData);
        });

        // 参加者データ（備考含む）を初期化
        function initializeParticipantData() {
            participantData.clear(); 
            FAMILIES.forEach(family => {
                family.members.forEach(member => {
                    // デフォルトデータとマスターデータをマージ
                    const defaultData = { 
                        grade: '', school: '', other: '', memo: '',
                        ...member.data 
                    };
                    
                    // isFlagTarget: false の場合はフラグを強制的にクリア
                    if (!member.isFlagTarget) {
                        defaultData.grade = '';
                        defaultData.school = '';
                        defaultData.other = '';
                    }
                    participantData.set(member.id, defaultData);
                });
            });
        }

        // ステップ1: 参加者リストを描画
        function renderParticipantList() {
            participantListEl.innerHTML = '';
            FAMILIES.forEach(family => {
                const details = document.createElement('details');
                details.className = 'bg-gray-50 rounded border';
                details.open = true; // ★デフォルトで開く
                
                const summary = document.createElement('summary');
                summary.className = 'p-3 cursor-pointer select-none';
                
                // summaryの中身をflexで構築
                const summaryContent = document.createElement('div');
                summaryContent.className = 'flex justify-between items-center';
                
                const familyNameSpan = document.createElement('span');
                familyNameSpan.className = 'font-semibold';
                familyNameSpan.textContent = family.familyName;
                
                // ★一括チェックボタン
                const buttonGroup = document.createElement('div');
                buttonGroup.className = 'space-x-2';
                buttonGroup.innerHTML = `
                    <button data-family-id="${family.familyName}" data-action="check-all" class="text-xs bg-blue-500 hover:bg-blue-600 text-white py-1 px-2 rounded">全員参加</button>
                    <button data-family-id="${family.familyName}" data-action="uncheck-all" class="text-xs bg-gray-400 hover:bg-gray-500 text-white py-1 px-2 rounded">全員不参加</button>
                `;
                
                summaryContent.appendChild(familyNameSpan);
                summaryContent.appendChild(buttonGroup);
                summary.appendChild(summaryContent);
                
                const memberList = document.createElement('div');
                memberList.className = 'p-3 border-t border-gray-200 space-y-3';

                family.members.forEach(p => {
                    const isChecked = selectedParticipantIds.has(p.id);
                    const wrapper = document.createElement('div');
                    wrapper.className = 'ml-4';

                    // 参加者名とチェックボックス
                    const participantDiv = document.createElement('div');
                    participantDiv.className = 'flex items-center';
                    participantDiv.innerHTML = `
                        <input type="checkbox" id="p-${p.id}" data-id="${p.id}" data-family-id="${family.familyName}" data-action="select-participant" class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${isChecked ? 'checked' : ''}>
                        <label for="p-${p.id}" class="text-gray-700">${p.name} (${p.type})</label>
                    `;
                    wrapper.appendChild(participantDiv);
                    
                    // データ入力欄
                    const data = participantData.get(p.id) || { grade: '', school: '', other: '', memo: '' };
                    const dataDiv = document.createElement('div');
                    dataDiv.id = `data-inputs-${p.id}`; 
                    dataDiv.className = `ml-8 mt-1.5 grid grid-cols-4 gap-2 ${isChecked ? '' : 'opacity-50'}`;
                    
                    if (p.isFlagTarget) {
                        dataDiv.innerHTML = `
                            <input type="text" data-id="${p.id}" data-type="grade" value="${data.grade || ''}" placeholder="学年" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                            <input type="text" data-id="${p.id}" data-type="school" value="${data.school || ''}" placeholder="学校" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                            <input type="text" data-id="${p.id}" data-type="other" value="${data.other || ''}" placeholder="その他" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                            <input type="text" data-id="${p.id}" data-type="memo" value="${data.memo || ''}" placeholder="備考" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                        `;
                    } else {
                        // isFlagTarget: false の場合は備考欄のみ
                        dataDiv.innerHTML = `
                            <div class="col-span-3"></div> <!-- 空白 -->
                            <input type="text" data-id="${p.id}" data-type="memo" value="${data.memo || ''}" placeholder="備考" class="w-full text-sm p-1 border rounded shadow-sm" ${isChecked ? '' : 'disabled'}>
                        `;
                    }
                    wrapper.appendChild(dataDiv);
                    memberList.appendChild(wrapper);
                });
                details.appendChild(summary);
                details.appendChild(memberList);
                participantListEl.appendChild(details);
            });
        }

        // ステップ2: 車リストを描画
        function renderCarList() {
            carListEl.innerHTML = '';
            AVAILABLE_CARS_INFO.forEach(car => {
                const family = FAMILIES.find(f => f.familyName === car.familyName);
                const driverOptions = family ? family.members : ALL_PARTICIPANTS_FLAT; 
                
                // ★デフォルトドライバーの選定
                let defaultDriverId = selectedDrivers.get(car.id) || ''; // 既に選択されていればそれを優先
                if (!defaultDriverId && family) {
                    const father = family.members.find(m => m.name.includes('父') || m.name.includes('監督'));
                    const mother = family.members.find(m => m.name.includes('母'));
                    
                    if (father) {
                        defaultDriverId = father.id;
                    } else if (mother) {
                        defaultDriverId = mother.id;
                    }
                    // デフォルト設定された場合、Mapにも保存
                    if (defaultDriverId) {
                        selectedDrivers.set(car.id, defaultDriverId);
                    }
                }
                
                const isChecked = selectedCarIds.has(car.id);
                const driverId = defaultDriverId; // 決定したIDを使用
                const hasLuggage = selectedLuggage.has(car.id);
                const div = document.createElement('div');
                div.className = 'bg-gray-50 rounded border p-3';
                div.dataset.carId = car.id;
                div.innerHTML = `
                    <div class="flex items-center">
                        <input type="checkbox" id="c-${car.id}" data-id="${car.id}" data-action="select-car" class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${isChecked ? 'checked' : ''}>
                        <label for="c-${car.id}" class="font-semibold">${car.name} (定員${car.baseCapacity}名)</label>
                    </div>
                    <div id="car-options-${car.id}" class="ml-8 mt-3 space-y-3 ${isChecked ? '' : 'hidden'}">
                        <div>
                            <label for="driver-${car.id}" class="block text-sm font-medium text-gray-700">ドライバー:</label>
                            <select id="driver-${car.id}" data-action="select-driver" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                                <option value="">選択してください</option>
                                ${driverOptions.map(p => `<option value="${p.id}" ${driverId === p.id ? 'selected' : ''}>${p.name} (${p.type})</option>`).join('')}
                            </select>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="luggage-${car.id}" data-action="select-luggage" class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${hasLuggage ? 'checked' : ''}>
                            <label for="luggage-${car.id}" class="text-sm text-gray-700">荷物あり (乗客定員1名)</label>
                        </div>
                    </div>
                `;
                carListEl.appendChild(div);
            });
        }

        // ステップ3: 除外リストを描画
        function renderExclusionList() {
            exclusionListEl.innerHTML = '';
            const participants = ALL_PARTICIPANTS_FLAT.filter(p => selectedParticipantIds.has(p.id));
            if (participants.length === 0) {
                exclusionListEl.innerHTML = '<p class="text-gray-500 text-sm">ステップ1で参加者を選択してください。</p>';
                return;
            }
            participants.forEach(p => {
                const div = document.createElement('div');
                div.className = 'flex items-center';
                div.innerHTML = `
                    <input type="checkbox" id="ex-${p.id}" data-id="${p.id}" data-action="exclude-participant" class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${excludedParticipantIds.has(p.id) ? 'checked' : ''}>
                    <label for="ex-${p.id}" class="text-gray-700">${p.name} (${p.type})</label>
                `;
                exclusionListEl.appendChild(div);
            });
        }

        // ステップ5: 割り当て結果を描画
        function renderResults(assignments) {
            resultsEl.innerHTML = '';
            
            if (assignments.length === 0) {
                resultsEl.innerHTML = `<p id="results-placeholder" class="text-gray-500 text-sm bg-white p-4 rounded-lg shadow min-h-[50px] md:col-span-3">ステップ4の「割り当て実行」を押してください。</p>`;
                const placeholder = document.getElementById('results-placeholder');
                if (placeholder) {
                     if (window.innerWidth >= 768) { 
                        placeholder.style.gridColumn = `span ${LAYOUT_COLUMNS}`;
                    } else {
                        placeholder.style.gridColumn = 'auto';
                    }
                }
                return;
            }

            assignments.forEach(car => {
                const card = document.createElement('div');
                card.id = `car-result-${car.id}`;
                card.dataset.carId = car.id; 
                card.className = 'bg-white border rounded-lg shadow-md car-dropzone';
                
                let headerHtml = '';
                let driverHtml = '';
                
                if (car.id === 'excluded-car') {
                    headerHtml = `
                        <div class="p-4 border-b bg-gray-100">
                            <h4 class="font-bold text-lg text-gray-700">${car.name}</h4>
                            <p class="text-sm text-gray-600">合計: ${car.members.length}名</p>
                        </div>`;
                    driverHtml = `<div id="driver-dropzone-${car.id}" class="driver-dropzone"></div>`; // 空のドロップゾーン
                } else {
                    const vacancy = car.capacity - car.members.length;
                    const luggageInfo = car.hasLuggage ? ' (荷物あり)' : '';
                    headerHtml = `
                        <div class="p-4 border-b">
                            <h4 class="font-bold text-lg">${car.name} ${luggageInfo}</h4>
                            <p class="text-sm font-medium ${vacancy < 0 ? 'text-red-600' : 'text-blue-600'}">
                                定員 ${car.capacity}名 (空き ${vacancy}名)
                            </p>
                        </div>`;
                    
                    const d = car.driver;
                    if (d) {
                        const memo = (participantData.get(d.id)?.memo || '').trim();
                        driverHtml = `
                        <div id="driver-dropzone-${car.id}" class="p-4 border-b driver-dropzone" data-drag-handle="true">
                            <li id="p-result-${d.id}" data-participant-id="${d.id}" data-is-driver="true" draggable="true" 
                                class="p-2 bg-blue-100 rounded shadow-sm flex justify-between items-center draggable-item">
                                <div data-drag-handle="true" class="min-w-0">
                                    <span class="font-semibold text-blue-800 break-words" data-drag-handle="true">[D] ${d.name} (${d.type})</span>
                                    ${memo ? `<span class="text-xs text-blue-600 ml-2 break-words" data-drag-handle="true">(${memo})</span>` : ''}
                                </div>
                            </li>
                        </div>`;
                    } else {
                         driverHtml = `
                         <div id="driver-dropzone-${car.id}" class="p-4 border-b driver-dropzone min-h-[50px] bg-red-50">
                             <p class="text-red-700 text-sm">ドライバーがいません</p>
                         </div>`;
                    }
                }
                
                const membersHtml = car.members.map(p => {
                    const memo = (participantData.get(p.id)?.memo || '').trim();
                    const flags = [p.grade, p.school, p.other].filter(Boolean).join(' ');
                    return `
                    <li id="p-result-${p.id}" data-participant-id="${p.id}" data-is-driver="false" draggable="true" 
                        class="p-2 bg-gray-100 rounded shadow-sm flex justify-between items-center draggable-item" data-drag-handle="true">
                        <div data-drag-handle="true" class="min-w-0">
                            <span data-drag-handle="true" class="break-words">${p.name} (${p.type})</span>
                            ${memo ? `<span class="text-xs text-gray-500 ml-2 break-words" data-drag-handle="true">(${memo})</span>` : ''}
                        </div>
                        <span class="text-xs text-gray-400 ml-2 flex-shrink-0" data-drag-handle="true">${flags}</span>
                    </li>`;
                }).join('');

                card.innerHTML = `
                    ${headerHtml}
                    ${driverHtml}
                    <ul id="members-dropzone-${car.id}" class="p-4 space-y-2 min-h-[50px] members-dropzone">
                        ${membersHtml}
                    </ul>
                `;
                resultsEl.appendChild(card);
            });
        }


        // --- ドラッグ＆ドロップ (D&D) ---
        
        // ハイライトをすべてクリア
        function clearDragOverHighlights() {
            document.querySelectorAll('.draggable-item, .driver-dropzone, .members-dropzone')
                .forEach(el => {
                    el.classList.remove(
                        'drop-target-swap', 
                        'drop-target-insert-before', 
                        'drop-target-insert-after',
                        'drop-target-move',
                        'drop-target-full'
                    );
            });
        }
        
        // D&D (PC)
        function handleDragStart(e) {
            // イベントの発生源がドラッグハンドルかチェック
            if (!e.target.dataset.dragHandle) {
                e.preventDefault();
                return;
            }
            
            const targetElement = e.target.closest('.draggable-item');
            if (!targetElement) return;

            dragTargetId = targetElement.dataset.participantId;
            dragSourceCarId = targetElement.closest('.car-dropzone').dataset.carId;
            dragIsDriver = targetElement.dataset.isDriver === 'true';
            
            e.dataTransfer.effectAllowed = 'move';
            // e.dataTransfer.setData('text/plain', dragTargetId); // Firefoxのために必要
            
            // 少し遅らせてopacityを適用 (ゴースト要素に反映させないため)
            setTimeout(() => {
                 if(document.getElementById(targetElement.id)) { // 要素がまだ存在するか確認
                    targetElement.classList.add('opacity-50');
                 }
            }, 0);
            
            currentDropMode = null;
            currentDropTargetId = null;
        }

        // D&D (PC)
        function handleDragOver(e) {
            e.preventDefault(); 
            // 座標 (e.clientY) とドラッグ中の情報 (dragTargetId) を渡す
            updateDropTargetHighlights(e.target, e.clientY);
        }
        
        // D&D (PC)
        function handleDragLeave(e) {
            // マウスがウィンドウから外れた場合なども考慮
            if (e.relatedTarget && !e.currentTarget.contains(e.relatedTarget)) {
                clearDragOverHighlights();
                currentDropMode = null;
            }
        }
        
        // D&D (PC)
        function handleDrop(e) {
            e.preventDefault();
            performDropOperation();
            handleDragEndCleanup(); // Dropの直後にクリーンアップ
        }

        // D&D (PC)
        function handleDragEnd(e) {
            // Dropが発生しなかった場合（例：ウィンドウ外でドロップ）もクリーンアップ
            handleDragEndCleanup();
        }
        
        // ★★★ タッチ操作ハンドラ ★★★

        // ★タッチ開始 (D&D開始)
        function handleTouchStart(e) {
            if (!e.target.dataset.dragHandle) {
                return;
            }
            
            const targetElement = e.target.closest('.draggable-item');
            if (!targetElement) return;
            
            e.preventDefault(); // スクロールやテキスト選択を防止

            dragTargetId = targetElement.dataset.participantId;
            dragSourceCarId = targetElement.closest('.car-dropzone').dataset.carId;
            dragIsDriver = targetElement.dataset.isDriver === 'true';
            
            currentDropMode = null;
            currentDropTargetId = null;
            
            targetElement.classList.add('opacity-50');
            createGhostElement(targetElement);
            updateGhostPosition(e.touches[0]);
            
            lastTouchMoveEvent = e; 
        }

        // ★タッチ移動 (D&D中)
        function handleTouchMove(e) {
            if (!dragTargetId) return; 
            
            e.preventDefault(); 
            lastTouchMoveEvent = e; 
            
            updateGhostPosition(e.touches[0]);
            
            const touch = e.touches[0];
            // 指の下にある要素をリアルタイムで検出
            ghostElement.style.display = 'none'; 
            const elementUnderFinger = document.elementFromPoint(touch.clientX, touch.clientY);
            ghostElement.style.display = ''; 
            
            if (!elementUnderFinger) {
                clearDragOverHighlights();
                currentDropMode = null;
                currentDropTargetId = null;
                return;
            }

            // 座標 (touch.clientY) とドラッグ中の情報 (dragTargetId) を渡す
            updateDropTargetHighlights(elementUnderFinger, touch.clientY);
        }

        // ★タッチ終了 (D&D終了)
        function handleTouchEnd(e) {
            if (!dragTargetId) return;

            // ドロップ操作を実行
            performDropOperation();
            
            // クリーンアップ
            handleDragEndCleanup();
        }
        
        // ★タッチキャンセル
        function handleTouchCancel(e) {
            handleDragEndCleanup();
        }
        
        // ★★★ 共通ロジック (D&D, タッチ) ★★★
        
        // ★(共通) ドラッグ中のハイライト処理
        function updateDropTargetHighlights(elementUnder, clientY) {
            const dropzone = elementUnder.closest('.car-dropzone');
            if (!dropzone) {
                clearDragOverHighlights();
                currentDropMode = null;
                return;
            }

            const targetCarId = dropzone.dataset.carId;
            const targetCar = currentAssignments.find(c => c.id === targetCarId);
            
            const targetItem = elementUnder.closest('.draggable-item');
            const targetDriverZone = elementUnder.closest('.driver-dropzone');
            const targetMembersZone = elementUnder.closest('.members-dropzone');
            
            clearDragOverHighlights(); 
            currentDropMode = null;
            currentDropTargetId = null;
            
            // 定員オーバーチェック (別便カーは除く)
            const isMovingToDifferentCar = targetCarId !== dragSourceCarId;
            // 「乗客」を移動させようとしていて、かつ移動先が満車か
            const isFull = !dragIsDriver && targetCar && targetCar.id !== 'excluded-car' && targetCar.members.length >= targetCar.capacity;
            
            // 1. アイテムの上 (入れ替え or 挿入)
            if (targetItem) {
                const targetId = targetItem.dataset.participantId;
                if (targetId === dragTargetId) return; // 自分自身の上は無視

                const targetIsDriver = targetItem.dataset.isDriver === 'true';
                
                // 1a. ドライバー or ドライバー欄 が絡む場合 -> 入れ替え (Swap)
                if (targetIsDriver || dragIsDriver) {
                    // ドライバーと乗客を入れ替える場合、定員チェック
                    if (targetIsDriver && !dragIsDriver && isMovingToDifferentCar && isFull) {
                        targetDriverZone.classList.add('drop-target-full');
                    } else {
                        targetItem.classList.add('drop-target-swap');
                        currentDropMode = 'swap';
                        currentDropTargetId = targetId;
                    }
                } 
                // 1b. 乗客同士の場合 -> 挿入 (Insert)
                else {
                    if (isMovingToDifferentCar && isFull) {
                        targetMembersZone.classList.add('drop-target-full');
                    } else {
                        const rect = targetItem.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        
                        if (clientY < midY) {
                            targetItem.classList.add('drop-target-insert-before');
                            currentDropMode = 'insert-before';
                        } else {
                            targetItem.classList.add('drop-target-insert-after');
                            currentDropMode = 'insert-after';
                        }
                        currentDropTargetId = targetId;
                    }
                }
            }
            // 2. ドライバーゾーンの上 (入れ替え)
            else if (targetDriverZone) {
                if (dragIsDriver && !isMovingToDifferentCar) return; // ドライバーが自分のゾーンに戻る
                
                if (isFull && !dragIsDriver) { // 乗客をD欄に持ってきて満車
                     targetDriverZone.classList.add('drop-target-full');
                } else {
                    targetDriverZone.classList.add('drop-target-swap');
                    currentDropMode = 'swap';
                    currentDropTargetId = targetCar?.driver?.id || null;
                }
            } 
            // 3. 乗客ゾーンの上 (末尾へ移動)
            else if (targetMembersZone) {
                if (isMovingToDifferentCar && isFull) { 
                    targetMembersZone.classList.add('drop-target-full');
                } else {
                    targetMembersZone.classList.add('drop-target-move');
                    currentDropMode = 'move-to-end';
                }
            }
        }
        
        // ★(共通) ゴースト要素の作成 (タッチ用)
        function createGhostElement(targetElement) {
            if (ghostElement) ghostElement.remove();
            ghostElement = targetElement.cloneNode(true);
            ghostElement.id = 'ghost-element';
            ghostElement.style.position = 'absolute';
            ghostElement.style.zIndex = '1000';
            ghostElement.style.opacity = '0.8';
            ghostElement.style.pointerEvents = 'none'; 
            ghostElement.style.width = `${targetElement.offsetWidth}px`;
            document.body.appendChild(ghostElement);
        }

        // ★(共通) ゴースト要素の位置更新 (タッチ用)
        function updateGhostPosition(touch) {
            if (!ghostElement) return;
            ghostElement.style.left = `${touch.clientX - ghostElement.offsetWidth / 2}px`;
            ghostElement.style.top = `${touch.clientY - ghostElement.offsetHeight / 2}px`;
        }
        
        // ★(共通) ドラッグ終了時のクリーンアップ
        function handleDragEndCleanup() {
            if (ghostElement) {
                ghostElement.remove();
                ghostElement = null;
            }
            
            if (dragTargetId) {
                const el = document.getElementById(`p-result-${dragTargetId}`);
                if (el) el.classList.remove('opacity-50');
            }
            
            clearDragOverHighlights();
            dragTargetId = null;
            dragSourceCarId = null;
            dragIsDriver = false;
            currentDropMode = null;
            currentDropTargetId = null;
            lastTouchMoveEvent = null;
        }

        // ★★★ (共通) ドロップ処理 (データ更新) ★★★
        function performDropOperation() {
            
            if (!currentDropMode || !dragTargetId) {
                 if (document.querySelector('.drop-target-full')) {
                    showMessage('定員オーバーのため移動できません。', 'error');
                }
                return; // 有効なドロップ先がない
            }

            const targetElement = document.querySelector('.drop-target-swap, .drop-target-insert-before, .drop-target-insert-after, .drop-target-move');
            if (!targetElement) return; // 安全装置

            const targetCarId = targetElement.closest('.car-dropzone').dataset.carId;
            const sourceCar = currentAssignments.find(c => c.id === dragSourceCarId);
            const targetCar = currentAssignments.find(c => c.id === targetCarId);

            if (!sourceCar || !targetCar) return;

            // 1. ドラッグ元の参加者データを取得＆削除
            const sourceParticipant = findAndRemoveParticipant(dragSourceCarId, dragTargetId);
            if (!sourceParticipant) {
                console.error("Source participant not found.");
                return; 
            }

            let operationDone = false;
            const isMovingToDifferentCar = targetCarId !== dragSourceCarId;

            try {
                // --- 2a. 入れ替え (Swap) ---
                if (currentDropMode === 'swap') {
                    // currentDropTargetId は入れ替え対象の *participantId* (いない場合は null)
                    const targetParticipant = findAndRemoveParticipant(targetCarId, currentDropTargetId);

                    if (!targetParticipant) {
                        // ターゲットがいない（例：空のD欄へドロップ）
                        if (targetCar.id === 'excluded-car') { /* 別便カーのD欄にはドロップ不可 */ }
                        else {
                            targetCar.driver = sourceParticipant; // D欄にセット
                            operationDone = true;
                        }
                    } else {
                        // ターゲットがいる場合
                        addParticipant(sourceCar, targetParticipant); // 元の車にターゲットを追加
                        addParticipant(targetCar, sourceParticipant); // 新しい車にソースを追加
                        operationDone = true;
                    }
                }
                // --- 2b. 挿入 (Insert Before / After) ---
                else if (currentDropMode === 'insert-before' || currentDropMode === 'insert-after') {
                    const targetIndex = targetCar.members.findIndex(p => p.id === currentDropTargetId);
                    if (targetIndex > -1) {
                        const insertIndex = (currentDropMode === 'insert-before') ? targetIndex : targetIndex + 1;
                        targetCar.members.splice(insertIndex, 0, sourceParticipant);
                        operationDone = true;
                    }
                }
                // --- 2c. 末尾へ移動 (Move to End) ---
                else if (currentDropMode === 'move-to-end') {
                    targetCar.members.push(sourceParticipant);
                    operationDone = true;
                }
            } catch (err) {
                console.error("Drop operation failed:", err);
            }

            // 3. 操作失敗/キャンセルの場合は元に戻す
            if (!operationDone) {
                addParticipant(sourceCar, sourceParticipant, dragIsDriver); // 元の位置に戻す
            }
            
            // 4. ドライバー自動昇格/降格処理
            [sourceCar, targetCar].forEach(car => {
                if (car.id === 'excluded-car') return; 
                // Dが空席になり、乗客がいる場合
                if (!car.driver && car.members.length > 0) {
                    car.driver = car.members.splice(0, 1)[0];
                }
            });
            
            // 5. UI全体を再描画
            renderResults(currentAssignments);
            updateTextOutput();
            hideMessage();
        }

        // (共通) D&Dヘルパー: 指定の車に参加者を追加（Dか乗客か判断）
        function addParticipant(car, participant, forceDriver = false) {
             if (car.id === 'excluded-car') {
                 car.members.push(participant);
                 return;
             }
             // D欄が空か、forceDriver=trueならDに
             if (forceDriver || !car.driver) {
                 if (car.driver) { // 既にDがいたら乗客に降格
                     car.members.unshift(car.driver);
                 }
                 car.driver = participant;
             } else {
                 car.members.push(participant);
             }
        }
        
        // (共通) D&Dヘルパー: IDで参加者を探して削除 (D/乗客問わず)
        function findAndRemoveParticipant(carId, pId) {
            const car = currentAssignments.find(c => c.id === carId);
            if (!car || !pId) return null;
            
            // ドライバーかチェック
            if (car.driver && car.driver.id === pId) {
                const p = car.driver;
                car.driver = null; 
                return p;
            }
            // 乗客かチェック
            const index = car.members.findIndex(p => p.id === pId);
            if (index > -1) {
                return car.members.splice(index, 1)[0]; 
            }
            return null; // 見つからなかった
        }


        // --- イベントハンドラ ---

        function handleParticipantChange(e) {
            const target = e.target;
            if (target.type === 'checkbox' && target.dataset.action === 'select-participant') {
                const id = target.dataset.id;
                const dataEl = document.getElementById(`data-inputs-${id}`); 
                
                if (target.checked) {
                    selectedParticipantIds.add(id);
                    if (dataEl) {
                        dataEl.classList.remove('opacity-50');
                        dataEl.querySelectorAll('input, textarea').forEach(input => input.disabled = false);
                    }
                } else {
                    selectedParticipantIds.delete(id);
                    if (dataEl) {
                        dataEl.classList.add('opacity-50');
                        dataEl.querySelectorAll('input, textarea').forEach(input => input.disabled = true);
                    }
                    if (excludedParticipantIds.has(id)) {
                        excludedParticipantIds.delete(id);
                    }
                }
                renderExclusionList();
            }
        }
        
        // ★一括チェック
        function handleFamilyCheck(e) {
             const target = e.target;
             const action = target.dataset.action;
             const familyName = target.dataset.familyId;
             
             if (!action || !familyName) return;
             
             // summaryをクリックした際のイベント伝播を止める
             e.preventDefault();
             e.stopPropagation();
             
             const family = FAMILIES.find(f => f.familyName === familyName);
             if (!family) return;
             
             const shouldCheck = (action === 'check-all');
             
             family.members.forEach(member => {
                 const checkbox = document.getElementById(`p-${member.id}`);
                 if (checkbox && checkbox.checked !== shouldCheck) { // 状態が変わる場合のみ発火
                     checkbox.checked = shouldCheck;
                     // イベントを強制発火させて状態を更新
                     checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                 }
             });
        }

        function handleParticipantDataInput(e) {
            const target = e.target;
            if (target.dataset.id && target.dataset.type) {
                const id = target.dataset.id;
                const type = target.dataset.type;
                const value = target.value;
                
                const data = participantData.get(id) || { grade: '', school: '', other: '', memo: '' };
                data[type] = value;
                participantData.set(id, data);
            }
        }

        function handleCarChange(e) {
            const target = e.target;
            const carId = target.closest('[data-car-id]')?.dataset.carId;
            if (!carId) return;

            const action = target.dataset.action;

            if (action === 'select-car') {
                if (target.checked) {
                    selectedCarIds.add(carId);
                    document.getElementById(`car-options-${carId}`).classList.remove('hidden');
                } else {
                    selectedCarIds.delete(carId);
                    // selectedDrivers.delete(carId); // デフォルト選択を残すため削除しない
                    selectedLuggage.delete(carId);
                    document.getElementById(`car-options-${carId}`).classList.add('hidden');
                }
            } else if (action === 'select-driver') {
                if (target.value) {
                    selectedDrivers.set(carId, target.value);
                } else {
                    selectedDrivers.delete(carId);
                }
            } else if (action === 'select-luggage') {
                if (target.checked) {
                    selectedLuggage.add(carId);
                } else {
                    selectedLuggage.delete(carId);
                }
            }
        }

        function handleExclusionChange(e) {
            const target = e.target;
            if (target.type === 'checkbox' && target.dataset.action === 'exclude-participant') {
                const id = target.dataset.id;
                if (target.checked) {
                    excludedParticipantIds.add(id);
                } else {
                    excludedParticipantIds.delete(id);
                }
            }
        }

        function handleAssignment() {
            if (selectedCarIds.size === 0) {
                showMessage('ステップ2で車を1台以上選択してください。', 'error');
                return;
            }

            let errors = [];
            let driverMap = new Map(); // carId -> driverObject
            let selectedCarsData = [];
            
            // 参加者データを準備
            const allParticipantsWithData = ALL_PARTICIPANTS_FLAT
                .filter(p => selectedParticipantIds.has(p.id)) 
                .map(p => {
                    const family = FAMILIES.find(f => f.members.some(m => m.id === p.id));
                    const data = participantData.get(p.id) || {};
                    return {
                        ...p,
                        grade: data.grade || '',
                        school: data.school || '',
                        other: data.other || '',
                        memo: data.memo || '',
                        familyName: family ? family.familyName : null
                    };
                });


            // 車データとドライバーを検証
            selectedCarIds.forEach(carId => {
                const driverId = selectedDrivers.get(carId);
                if (!driverId) {
                    errors.push(`${AVAILABLE_CARS_INFO.find(c=>c.id === carId).name} のドライバーが選択されていません。`);
                    return;
                }
                
                const driver = allParticipantsWithData.find(p => p.id === driverId);
                if (!driver) { 
                    // 参加者リストにはいないが、マスターリストにはいる場合
                     const driverInfo = ALL_PARTICIPANTS_FLAT.find(p=>p.id === driverId);
                     if (driverInfo) {
                         errors.push(`ドライバー (${driverInfo.name} (${driverInfo.type})) がステップ1の参加者に含まれていません。`);
                     } else {
                         errors.push(`ID ${driverId} のドライバーが見つかりません。`);
                     }
                     return;
                }
                
                if ([...driverMap.values()].some(d => d.id === driverId)) {
                    errors.push(`ドライバー (${driver.name} (${driver.type})) が複数の車に割り当てられています。`);
                }
                driverMap.set(carId, driver);
                
                const carInfo = AVAILABLE_CARS_INFO.find(c => c.id === carId);
                const hasLuggage = selectedLuggage.has(carId);
                let actualCapacity = carInfo.baseCapacity - 1; 
                if (hasLuggage) {
                    actualCapacity = 1; 
                }

                selectedCarsData.push({
                    id: carId,
                    name: carInfo.name,
                    familyName: carInfo.familyName,
                    driverId: driverId, 
                    capacity: actualCapacity, 
                    hasLuggage: hasLuggage
                });
            });

            if (errors.length > 0) {
                showMessage(errors.join('<br>'), 'error');
                return;
            }

            // 割り当て対象の乗客を決定
            const driverIds = new Set([...driverMap.values()].map(d => d.id));
            let participantsToAssign = allParticipantsWithData.filter(p => {
                return !driverIds.has(p.id) && !excludedParticipantIds.has(p.id);
            });
            
            let excludedParticipants = allParticipantsWithData.filter(p => {
                return excludedParticipantIds.has(p.id) && !driverIds.has(p.id); 
            });

            const totalParticipants = participantsToAssign.length;
            const totalCapacity = selectedCarsData.reduce((sum, car) => sum + car.capacity, 0);

            if (totalParticipants > totalCapacity) {
                showMessage(`定員オーバーです。参加者 ${totalParticipants}人 に対して、車の乗客定員は合計 ${totalCapacity}人 です。`, 'error');
            } else {
                hideMessage();
            }

            // ★修正されたロジックを呼び出す
            const assignments = allocateParticipants(participantsToAssign, selectedCarsData, driverMap);

            assignments.push({
                id: 'excluded-car',
                name: '別便',
                capacity: 999,
                driver: null,
                members: excludedParticipants,
                hasLuggage: false
            });

            currentAssignments = assignments; 
            renderResults(currentAssignments);
            
            // D&DのためにDOM要素をキャッシュ
            currentAssignments.forEach(car => {
                car.element = document.getElementById(`car-result-${car.id}`);
            });

            updateTextOutput();
        }
        

        // --- メッセージとロジック ---

        function showMessage(message, type = 'info') {
            messageText.innerHTML = message;
            messageContainer.classList.remove('hidden', 'bg-red-100', 'border-red-400', 'text-red-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700');
            if (type === 'error') {
                messageContainer.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
            } else {
                messageContainer.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
            }
            messageContainer.classList.remove('hidden');
        }

        function hideMessage() {
            messageContainer.classList.add('hidden');
        }

        // ★★★ 割り当てロジック (フラグ一致優先度を修正) ★★★
        function allocateParticipants(participants, cars, driverMap) {
            // 1. 割り当て結果の器を初期化 (ドライバーをセット)
            let assignments = cars.map(car => ({ 
                ...car, 
                driver: driverMap.get(car.id) || null, // ドライバーをセット
                members: [] 
            }));
            
            if (participants.length === 0) return assignments;

            let remainingParticipants = [...participants]; 
            
            const typePriority = { '保護者': 1, '兄弟': 2, '選手': 3, 'その他': 4 };

            // --- 優先度1: 家族を自分の車に乗せる ---
            assignments.forEach(car => {
                if (!car.driver || !car.familyName) return;
                
                // ドライバーの家族名と車の家族名が一致する場合のみ
                if (car.driver.familyName === car.familyName) {
                    let familyMembersInThisCar = remainingParticipants
                        .filter(p => p.familyName === car.familyName) // 同じ家族
                        .sort((a, b) => (typePriority[a.type] || 9) - (typePriority[b.type] || 9));

                    familyMembersInThisCar.forEach(member => {
                        if (car.members.length < car.capacity) {
                            car.members.push(member);
                            remainingParticipants = remainingParticipants.filter(p => p.id !== member.id);
                        }
                    });
                }
            });

            // --- 優先度2: フラグ一致 (新しいロジック) ---
            
            // フラグ一致スコアを計算する関数
            function getFlagMatchScore(pA, pB) {
                // pA, pB は完全な参加者オブジェクト
                if (!pA || !pB || !pA.isFlagTarget || !pB.isFlagTarget) return 0;
                let score = 0;
                // grade, school, other が空文字列やnullでないことを確認してから比較
                if (pA.grade && pA.grade === pB.grade) score++;
                if (pA.school && pA.school === pB.school) score++;
                if (pA.other && pA.other === pB.other) score++;
                return score;
            }

            // 残った参加者をシャッフルし、フラグ対象者を優先
            let participantsToProcess = remainingParticipants.sort((a, b) => {
                if (a.isFlagTarget !== b.isFlagTarget) {
                    return a.isFlagTarget ? -1 : 1; // フラグ対象者を先に
                }
                return Math.random() - 0.5; // ランダム性
            });
            
            let stillRemaining = []; // どの車とも一致しなかった参加者

            participantsToProcess.forEach(participant => {
                let bestCars = []; // ベストスコアの車を複数保持
                let maxScore = 0;

                // 参加者(participant)にとって最適な車を探す
                assignments.forEach(car => {
                    // 1. 定員に空きがあるか
                    if (car.members.length >= car.capacity) return;

                    // 2. 車内の乗客との合計一致スコアを計算
                    let currentCarScore = 0;
                    car.members.forEach(member => {
                        currentCarScore += getFlagMatchScore(participant, member);
                    });

                    // 3. ベストスコアを更新
                    if (currentCarScore > maxScore) {
                        maxScore = currentCarScore;
                        bestCars = [car]; // 新しいベストスコア
                    } 
                    // 4. 同一ポイントの場合はリストに追加
                    else if (currentCarScore > 0 && currentCarScore === maxScore) {
                        bestCars.push(car);
                    }
                });

                // 5. ベストな車（スコア>0）が見つかったら割り当て
                if (bestCars.length > 0) {
                    // 同一スコアの車が複数あればランダムで1台選ぶ
                    const bestCar = bestCars[Math.floor(Math.random() * bestCars.length)];
                    bestCar.members.push(participant);
                } else {
                    // スコア0の参加者は後回し
                    stillRemaining.push(participant);
                }
            });

            
            // --- 優先度3: 残りの個人 (スコア0の人たち) ---
            if (stillRemaining.length > 0) {
                
                // 空きが多い順にソート
                let carsWithVacancy = assignments
                    .map(car => ({ carRef: car, vacancy: car.capacity - car.members.length }))
                    .filter(c => c.vacancy > 0)
                    .sort((a, b) => b.vacancy - a.vacancy); 

                let carIndex = 0;
                stillRemaining.forEach(participant => {
                    if (carsWithVacancy.length === 0) return; // 満車

                    let assigned = false;
                    let initialCarIndex = carIndex;
                    
                    while(!assigned) {
                        if (carsWithVacancy.length === 0) break; // 途中で満車になった
                        
                        // carIndexが範囲外にならないように調整
                        carIndex = carIndex % carsWithVacancy.length;
                        
                        const targetCarInfo = carsWithVacancy[carIndex];
                        
                        if (targetCarInfo.carRef.members.length < targetCarInfo.carRef.capacity) {
                            targetCarInfo.carRef.members.push(participant);
                        	targetCarInfo.vacancy--;
                            assigned = true;
                            
                            // この車が満車になったらリストから削除
                            if (targetCarInfo.vacancy <= 0) {
                                carsWithVacancy.splice(carIndex, 1);
                            } else {
                                carIndex++; // 次の車へ
                            }
                        } else {
                            // 満車だった場合（起こりにくいはずだが念のため）
                            carsWithVacancy.splice(carIndex, 1);
                        }
                        
                        // 1周しても空きがなかった（＝全車満車）
                        if (carsWithVacancy.length > 0 && carIndex % carsWithVacancy.length === initialCarIndex && !assigned) {
                            break;
                        }
                    }
                });
            }
            
            return assignments;
        }


        // アコーディオンの全開/全閉
        function handleToggleDetails() {
            const detailsElements = participantListEl.querySelectorAll('details');
            const shouldOpen = toggleDetailsButton.textContent.includes('開く');
            detailsElements.forEach(details => {
                details.open = shouldOpen;
            });
            toggleDetailsButton.textContent = shouldOpen ? 'すべて閉じる' : 'すべて開く';
        }


        // --- ファイル入出力・テキスト出力機能 ---

        function getCurrentState() {
            return {
                selectedParticipantIds: Array.from(selectedParticipantIds),
                selectedCarIds: Array.from(selectedCarIds),
                selectedDrivers: Array.from(selectedDrivers.entries()),
                selectedLuggage: Array.from(selectedLuggage),
                excludedParticipantIds: Array.from(excludedParticipantIds),
                participantData: Array.from(participantData.entries()) 
            };
        }

        function restoreState(state) {
            selectedParticipantIds = new Set(state.selectedParticipantIds || []);
            selectedCarIds = new Set(state.selectedCarIds || []);
            selectedDrivers = new Map(state.selectedDrivers || []);
            selectedLuggage = new Set(state.selectedLuggage || []);
            excludedParticipantIds = new Set(state.excludedParticipantIds || []);
            participantData = new Map(state.participantData || []); 
            
            if (participantData.size === 0) {
                initializeParticipantData(); 
            }

            currentAssignments = [];
        }

        function handleExportState() {
            const state = getCurrentState();
            const jsonString = JSON.stringify(state, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `car_assignment_state_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('現在の状態をファイルに保存しました。', 'info');
        }

        function handleImportState(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const state = JSON.parse(event.target.result);
                    restoreState(state);
                    
                    renderParticipantList();
                    renderCarList();
                    renderExclusionList();
                    renderResults([]); // 結果をリセット
                    
                    textOutputContainer.classList.add('hidden'); 
                    
                    showMessage('状態を読み込みました。', 'info');
                } catch (err) {
                    console.error('Error parsing JSON state:', err);
                    showMessage('ファイルの読み込みに失敗しました。無効なJSONファイルです。', 'error');
                }
                e.target.value = null;
            };
            reader.readAsText(file);
        }

        function handleShowTextOutput() {
            if (currentAssignments.length === 0) {
                showMessage('テキスト出力する結果がありません。先に「割り当て実行」を押してください。', 'error');
                return;
            }
            textOutputContainer.classList.toggle('hidden');
            if (!textOutputContainer.classList.contains('hidden')) {
                updateTextOutput(); 
            }
        }

        function updateTextOutput() {
            if (currentAssignments.length === 0) {
                textOutputEl.value = '';
                return;
            }

            // 1. 車の割り当て
            const carLines = currentAssignments
                .filter(car => car.id !== 'excluded-car') 
                .map(car => {
                
                const carName = car.name.replace(/の車|家の車/g, 'カー');
                
                let driverName = ' (ドライバー未定)';
                if (car.driver) {
                    const memo = (participantData.get(car.driver.id)?.memo || '').trim();
                    driverName = car.driver.name + (memo ? ` [${memo}]` : '');
                }
                
                const members = car.members.map(p => {
                    let name = p.name;
                    if (p.type === '選手') name = '★' + name;
                    const memo = (participantData.get(p.id)?.memo || '').trim();
                    return name + (memo ? ` [${memo}]` : '');
                });
                
                const luggage = car.hasLuggage ? '荷物' : null;
                
                const parts = [driverName, ...members];
                if (luggage) parts.push(luggage);
                
                return `${carName} (${parts.join(', ')})`;
            });

            // 2. 別便のメンバー
            const excludedCar = currentAssignments.find(car => car.id === 'excluded-car');
            let excludedLines = [];
            if (excludedCar && excludedCar.members.length > 0) {
                excludedLines.push('-------');
                excludedLines.push('□別便');
                excludedCar.members.forEach(p => {
                    let name = p.name;
                    if (p.type === '選手') name = '★' + name;
                    const memo = (participantData.get(p.id)?.memo || '').trim();
                    excludedLines.push(name + (memo ? ` [${memo}]` : ''));
                });
            }

            textOutputEl.value = [...carLines, ...excludedLines].join('\n');
        }

        function handleCopyTextOutput() {
            if (!textOutputEl.value) return;

            try {
                navigator.clipboard.writeText(textOutputEl.value).then(() => {
                    showMessage('クリップボードにコピーしました。', 'info');
                }, (err) => {
                    legacyCopy(textOutputEl.value);
                });
            } catch (err) {
                legacyCopy(textOutputEl.value);
            }
        }

        function legacyCopy(text) {
             const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed'; 
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage('クリップボードにコピーしました。', 'info');
                } else {
                    showMessage('コピーに失敗しました。', 'error');
                }
            } catch (err) {
                showMessage('コピーに失敗しました。', 'error');
            }
            document.body.removeChild(textArea);
        }

        // --- マスターデータ入出力 ---

        function handleExportMasterData() {
            const masterData = {
                families: FAMILIES,
                cars: AVAILABLE_CARS_INFO
            };
            const jsonString = JSON.stringify(masterData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `car_assignment_master_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('現在のマスターデータをファイルに保存しました。', 'info');
        }

        function handleImportMasterData(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const masterData = JSON.parse(event.target.result);
                    
                    if (!masterData || !Array.isArray(masterData.families) || !Array.isArray(masterData.cars)) {
                        throw new Error('JSONの形式が正しくありません。 "families" と "cars" の配列が必要です。');
                    }

                    FAMILIES = masterData.families;
                    AVAILABLE_CARS_INFO = masterData.cars;
                    
                    ALL_PARTICIPANTS_FLAT = FAMILIES.flatMap(f => f.members);

                    // 状態をリセット
                    restoreState({}); 
                    
                    initializeParticipantData(); 
                    renderParticipantList();
                    renderCarList();
                    renderExclusionList();
                    renderResults([]); // 結果をリセット
                    
                    textOutputContainer.classList.add('hidden'); 
                    toggleDetailsButton.textContent = 'すべて閉じる'; // UIをリセット
                    
                    showMessage('マスターデータを読み込み、アプリをリセットしました。', 'info');
                } catch (err) {
                    console.error('Error parsing master data JSON:', err);
                    showMessage(`マスターデータの読み込みに失敗しました: ${err.message}`, 'error');
                }
                e.target.value = null;
            };
            reader.readAsText(file);
        }

    </script>

</body>
</html>
